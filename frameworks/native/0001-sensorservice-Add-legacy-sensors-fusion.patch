From 5d7cb43bc8cf8d371dd5cb5b37242ffa56d93d48 Mon Sep 17 00:00:00 2001
From: Rudolf Tammekivi <rtammekivi@gmail.com>
Date: Sat, 2 Feb 2013 15:30:52 +0200
Subject: [PATCH] sensorservice: Add legacy sensors fusion.

This change allows devices with accelerometer & magnetometer but
without gyroscope to still get virtual sensors such as Gravity,
Linear Acceleration, Orientation & Rotation Vector.

Can be enabled with BOARD_USE_LEGACY_SENSORS_FUSION := true

Change-Id: Ibb90b70845c766ab52c843557446e34649a7d6d9

sensorservice: update to N

References:
755c451 sensorservice: switch to use sp<> in sensor list
0cc8f80 Refactor sensor list in SensorService

Change-Id: I95881a97187c1917aafe058b090b2fa9c34bafa2
---
 services/sensorservice/Android.mk                  |  14 ++
 services/sensorservice/SensorService.cpp           |  29 ++++
 .../sensorservice/legacy/LegacyGravitySensor.cpp   |  98 +++++++++++++
 .../sensorservice/legacy/LegacyGravitySensor.h     |  53 +++++++
 .../legacy/LegacyLinearAccelerationSensor.cpp      |  82 +++++++++++
 .../legacy/LegacyLinearAccelerationSensor.h        |  50 +++++++
 .../legacy/LegacyOrientationSensor.cpp             | 158 +++++++++++++++++++++
 .../sensorservice/legacy/LegacyOrientationSensor.h |  56 ++++++++
 .../legacy/LegacyRotationVectorSensor.cpp          | 152 ++++++++++++++++++++
 .../legacy/LegacyRotationVectorSensor.h            |  56 ++++++++
 .../legacy/SecondOrderLowPassFilter.cpp            |  89 ++++++++++++
 .../legacy/SecondOrderLowPassFilter.h              |  73 ++++++++++
 12 files changed, 910 insertions(+)
 create mode 100644 services/sensorservice/legacy/LegacyGravitySensor.cpp
 create mode 100644 services/sensorservice/legacy/LegacyGravitySensor.h
 create mode 100644 services/sensorservice/legacy/LegacyLinearAccelerationSensor.cpp
 create mode 100644 services/sensorservice/legacy/LegacyLinearAccelerationSensor.h
 create mode 100644 services/sensorservice/legacy/LegacyOrientationSensor.cpp
 create mode 100644 services/sensorservice/legacy/LegacyOrientationSensor.h
 create mode 100644 services/sensorservice/legacy/LegacyRotationVectorSensor.cpp
 create mode 100644 services/sensorservice/legacy/LegacyRotationVectorSensor.h
 create mode 100644 services/sensorservice/legacy/SecondOrderLowPassFilter.cpp
 create mode 100644 services/sensorservice/legacy/SecondOrderLowPassFilter.h

diff --git a/services/sensorservice/Android.mk b/services/sensorservice/Android.mk
index 7b10319..de55657 100644
--- a/services/sensorservice/Android.mk
+++ b/services/sensorservice/Android.mk
@@ -20,6 +20,16 @@ LOCAL_SRC_FILES:= \
     SensorServiceUtils.cpp \
 
 
+ifeq ($(BOARD_USE_LEGACY_SENSORS_FUSION),true)
+# Legacy virtual sensors used in combination from accelerometer & magnetometer.
+LOCAL_SRC_FILES += \
+	legacy/SecondOrderLowPassFilter.cpp \
+	legacy/LegacyGravitySensor.cpp \
+	legacy/LegacyLinearAccelerationSensor.cpp \
+	legacy/LegacyOrientationSensor.cpp \
+	legacy/LegacyRotationVectorSensor.cpp
+endif
+
 LOCAL_CFLAGS:= -DLOG_TAG=\"SensorService\"
 
 LOCAL_CFLAGS += -Wall -Werror -Wextra
@@ -37,6 +47,10 @@ LOCAL_SHARED_LIBRARIES := \
     libgui \
     libcrypto
 
+ifeq ($(BOARD_USE_LEGACY_SENSORS_FUSION),true)
+    LOCAL_CFLAGS += -DUSE_LEGACY_SENSORS_FUSION
+endif
+
 LOCAL_MODULE:= libsensorservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index d8e0877..8404f5c 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -54,6 +54,13 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#ifdef USE_LEGACY_SENSORS_FUSION
+#include "legacy/LegacyGravitySensor.h"
+#include "legacy/LegacyLinearAccelerationSensor.h"
+#include "legacy/LegacyOrientationSensor.h"
+#include "legacy/LegacyRotationVectorSensor.h"
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -215,6 +222,28 @@ void SensorService::onFirstRef() {
                         (virtualSensorsNeeds & (1<<SENSOR_TYPE_GAME_ROTATION_VECTOR)) != 0;
                 registerSensor(new GameRotationVectorSensor(), !needGameRotationVector, true);
             }
+#ifdef USE_LEGACY_SENSORS_FUSION
+            else {
+                // Add Android virtual sensors if they're not already
+                // available in the HAL
+
+                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) {
+                    registerVirtualSensor( new LegacyRotationVectorSensor() );
+                }
+
+                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_GRAVITY)) {
+                    registerVirtualSensor( new LegacyGravitySensor(list, count) );
+                }
+
+                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_LINEAR_ACCELERATION)) {
+                    registerVirtualSensor( new LegacyLinearAccelerationSensor(list, count) );
+                }
+
+                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) {
+                    registerVirtualSensor( new LegacyOrientationSensor() );
+                }
+            }
+#endif
 
             if (hasAccel && hasMag) {
                 bool needGeoMagRotationVector =
diff --git a/services/sensorservice/legacy/LegacyGravitySensor.cpp b/services/sensorservice/legacy/LegacyGravitySensor.cpp
new file mode 100644
index 0000000..952d6ba
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyGravitySensor.cpp
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <math.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+
+#include <hardware/sensors.h>
+
+#include "LegacyGravitySensor.h"
+#include "SensorDevice.h"
+#include "SensorFusion.h"
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+LegacyGravitySensor::LegacyGravitySensor(sensor_t const* list, size_t count)
+    : mAccTime(0),
+      mLowPass(M_SQRT1_2, 1.5f),
+      mX(mLowPass), mY(mLowPass), mZ(mLowPass)
+{
+    for (size_t i=0 ; i<count ; i++) {
+        if (list[i].type == SENSOR_TYPE_ACCELEROMETER) {
+            mAccelerometer = Sensor(list + i);
+            break;
+        }
+    }
+
+    const sensor_t sensor = {
+        .name       = "Gravity Sensor",
+        .vendor     = "AOSP",
+        .version    = 3,
+        .handle     = '_grv',
+        .type       = SENSOR_TYPE_GRAVITY,
+        .maxRange   = GRAVITY_EARTH * 2,
+        .resolution = mAccelerometer.getResolution(),
+        .power      = mSensorFusion.getPowerUsage(),
+        .minDelay   = mSensorFusion.getMinDelay(),
+    };
+    mSensor = Sensor(&sensor);
+}
+
+bool LegacyGravitySensor::process(sensors_event_t* outEvent,
+        const sensors_event_t& event)
+{
+    const static double NS2S = 1.0 / 1000000000.0;
+    if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+        float x, y, z;
+        const double now = event.timestamp * NS2S;
+        if (mAccTime == 0) {
+            x = mX.init(event.acceleration.x);
+            y = mY.init(event.acceleration.y);
+            z = mZ.init(event.acceleration.z);
+        } else {
+            double dT = now - mAccTime;
+            mLowPass.setSamplingPeriod(dT);
+            x = mX(event.acceleration.x);
+            y = mY(event.acceleration.y);
+            z = mZ(event.acceleration.z);
+        }
+        mAccTime = now;
+        *outEvent = event;
+        outEvent->data[0] = x;
+        outEvent->data[1] = y;
+        outEvent->data[2] = z;
+        outEvent->sensor = '_grv';
+        outEvent->type = SENSOR_TYPE_GRAVITY;
+        return true;
+    }
+    return false;
+}
+
+status_t LegacyGravitySensor::activate(void* ident, bool enabled) {
+    return mSensorFusion.activate(FUSION_NOGYRO, ident, enabled);
+}
+
+status_t LegacyGravitySensor::setDelay(void* ident, int /*handle*/, int64_t ns) {
+    return mSensorFusion.setDelay(FUSION_NOGYRO, ident, ns);
+}
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
diff --git a/services/sensorservice/legacy/LegacyGravitySensor.h b/services/sensorservice/legacy/LegacyGravitySensor.h
new file mode 100644
index 0000000..5632209
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyGravitySensor.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_LEGACY_GRAVITY_SENSOR_H
+#define ANDROID_LEGACY_GRAVITY_SENSOR_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <gui/Sensor.h>
+
+#include "../SensorInterface.h"
+#include "SecondOrderLowPassFilter.h"
+
+// ---------------------------------------------------------------------------
+namespace android {
+// ---------------------------------------------------------------------------
+
+class SensorDevice;
+class SensorFusion;
+
+class LegacyGravitySensor : public VirtualSensor {
+    Sensor mAccelerometer;
+    double mAccTime;
+
+    SecondOrderLowPassFilter mLowPass;
+    CascadedBiquadFilter mX, mY, mZ;
+
+public:
+    LegacyGravitySensor(sensor_t const* list, size_t count);
+    virtual bool process(sensors_event_t* outEvent,
+            const sensors_event_t& event) override;
+    virtual status_t activate(void* ident, bool enabled) override;
+    virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
+};
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_LEGACY_GRAVITY_SENSOR_H
diff --git a/services/sensorservice/legacy/LegacyLinearAccelerationSensor.cpp b/services/sensorservice/legacy/LegacyLinearAccelerationSensor.cpp
new file mode 100644
index 0000000..be97865
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyLinearAccelerationSensor.cpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <math.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+
+#include <hardware/sensors.h>
+
+#include "LegacyLinearAccelerationSensor.h"
+#include "../SensorDevice.h"
+#include "../SensorFusion.h"
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+LegacyLinearAccelerationSensor::LegacyLinearAccelerationSensor(sensor_t const* list, size_t count)
+    : mGravitySensor(list, count)
+{
+    mData[0] = mData[1] = mData[2] = 0;
+
+    const Sensor &gsensor = mGravitySensor.getSensor();
+    const sensor_t sensor = {
+        .name       = "Linear Acceleration Sensor",
+        .vendor     = "AOSP",
+        .version    = gsensor.getVersion(),
+        .handle     = '_lin',
+        .type       = SENSOR_TYPE_LINEAR_ACCELERATION,
+        .maxRange   = gsensor.getMaxValue(),
+        .resolution = gsensor.getResolution(),
+        .power      = gsensor.getPowerUsage(),
+        .minDelay   = gsensor.getMinDelay(),
+    };
+    mSensor = Sensor(&sensor);
+}
+
+bool LegacyLinearAccelerationSensor::process(sensors_event_t* outEvent,
+        const sensors_event_t& event)
+{
+    bool result = mGravitySensor.process(outEvent, event);
+    if (result) {
+        if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+            mData[0] = event.acceleration.x;
+            mData[1] = event.acceleration.y;
+            mData[2] = event.acceleration.z;
+        }
+        outEvent->data[0] = mData[0] - outEvent->data[0];
+        outEvent->data[1] = mData[1] - outEvent->data[1];
+        outEvent->data[2] = mData[2] - outEvent->data[2];
+        outEvent->sensor = '_lin';
+        outEvent->type = SENSOR_TYPE_LINEAR_ACCELERATION;
+        return true;
+    }
+    return false;
+}
+
+status_t LegacyLinearAccelerationSensor::activate(void* ident, bool enabled) {
+    return mGravitySensor.activate(ident, enabled);
+}
+
+status_t LegacyLinearAccelerationSensor::setDelay(void* ident, int handle, int64_t ns) {
+    return mGravitySensor.setDelay(ident, handle, ns);
+}
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
diff --git a/services/sensorservice/legacy/LegacyLinearAccelerationSensor.h b/services/sensorservice/legacy/LegacyLinearAccelerationSensor.h
new file mode 100644
index 0000000..0efa775
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyLinearAccelerationSensor.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_LEGACY_LINEAR_ACCELERATION_SENSOR_H
+#define ANDROID_LEGACY_LINEAR_ACCELERATION_SENSOR_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <gui/Sensor.h>
+
+#include "../SensorInterface.h"
+#include "LegacyGravitySensor.h"
+
+// ---------------------------------------------------------------------------
+namespace android {
+// ---------------------------------------------------------------------------
+
+class SensorDevice;
+class SensorFusion;
+
+class LegacyLinearAccelerationSensor : public VirtualSensor {
+    LegacyGravitySensor mGravitySensor;
+    float mData[3];
+
+    virtual bool process(sensors_event_t* outEvent,
+            const sensors_event_t& event);
+public:
+    LegacyLinearAccelerationSensor(sensor_t const* list, size_t count);
+    virtual status_t activate(void* ident, bool enabled) override;
+    virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
+};
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_LEGACY_LINEAR_ACCELERATION_SENSOR_H
diff --git a/services/sensorservice/legacy/LegacyOrientationSensor.cpp b/services/sensorservice/legacy/LegacyOrientationSensor.cpp
new file mode 100644
index 0000000..11a383f
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyOrientationSensor.cpp
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <math.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+
+#include <hardware/sensors.h>
+
+#include "LegacyOrientationSensor.h"
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+template <typename T>
+static inline T clamp(T v) {
+    return v < 0 ? 0 : v;
+}
+
+LegacyOrientationSensor::LegacyOrientationSensor()
+    : mALowPass(M_SQRT1_2, 1.5f),
+      mAX(mALowPass), mAY(mALowPass), mAZ(mALowPass),
+      mMLowPass(M_SQRT1_2, 1.5f),
+      mMX(mMLowPass), mMY(mMLowPass), mMZ(mMLowPass)
+{
+    const sensor_t sensor = {
+        .name       = "Orientation Sensor",
+        .vendor     = "AOSP",
+        .version    = 1,
+        .handle     = '_ypr',
+        .type       = SENSOR_TYPE_ORIENTATION,
+        .maxRange   = 360.0f,
+        .resolution = 1.0f/256.0f, // FIXME: real value here
+        .power      = mSensorFusion.getPowerUsage(),
+        .minDelay   = mSensorFusion.getMinDelay(),
+    };
+    mSensor = Sensor(&sensor);
+}
+
+bool LegacyOrientationSensor::process(sensors_event_t* outEvent,
+        const sensors_event_t& event)
+{
+    const static double NS2S = 1.0 / 1000000000.0;
+    if (event.type == SENSOR_TYPE_MAGNETIC_FIELD) {
+        const double now = event.timestamp * NS2S;
+        if (mMagTime == 0) {
+            mMagData[0] = mMX.init(event.magnetic.x);
+            mMagData[1] = mMY.init(event.magnetic.y);
+            mMagData[2] = mMZ.init(event.magnetic.z);
+        } else {
+            double dT = now - mMagTime;
+            mMLowPass.setSamplingPeriod(dT);
+            mMagData[0] = mMX(event.magnetic.x);
+            mMagData[1] = mMY(event.magnetic.y);
+            mMagData[2] = mMZ(event.magnetic.z);
+        }
+        mMagTime = now;
+    }
+    if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+        const double now = event.timestamp * NS2S;
+        float Ax, Ay, Az;
+        if (mAccTime == 0) {
+            Ax = mAX.init(event.acceleration.x);
+            Ay = mAY.init(event.acceleration.y);
+            Az = mAZ.init(event.acceleration.z);
+        } else {
+            double dT = now - mAccTime;
+            mALowPass.setSamplingPeriod(dT);
+            Ax = mAX(event.acceleration.x);
+            Ay = mAY(event.acceleration.y);
+            Az = mAZ(event.acceleration.z);
+        }
+        mAccTime = now;
+        const float Ex = mMagData[0];
+        const float Ey = mMagData[1];
+        const float Ez = mMagData[2];
+        float Hx = Ey*Az - Ez*Ay;
+        float Hy = Ez*Ax - Ex*Az;
+        float Hz = Ex*Ay - Ey*Ax;
+        const float normH = sqrtf(Hx*Hx + Hy*Hy + Hz*Hz);
+        if (normH < 0.1f) {
+            // device is close to free fall (or in space?), or close to
+            // magnetic north pole. Typical values are  > 100.
+            return false;
+        }
+        const float invH = 1.0f / normH;
+        const float invA = 1.0f / sqrtf(Ax*Ax + Ay*Ay + Az*Az);
+        Hx *= invH;
+        Hy *= invH;
+        Hz *= invH;
+        Ax *= invA;
+        Ay *= invA;
+        Az *= invA;
+        const float Mx = Ay*Hz - Az*Hy;
+        const float My = Az*Hx - Ax*Hz;
+        //const float Mz = Ax*Hy - Ay*Hx;
+
+        // construct real rotation matrix
+        mat33_t R;
+        R[0].x = Hx;
+        R[0].y = Hy;
+        R[0].z = Hz;
+        R[1].x = Mx;
+        R[1].y = My;
+        R[2].x = Ax;
+        R[2].y = Ay;
+        R[2].z = Az;
+
+        vec3_t g;
+        const float rad2deg = 180 / M_PI;
+        g[0] = atan2f(-R[1][0], R[0][0])    * rad2deg;
+        g[1] = atan2f(-R[2][1], R[2][2])    * rad2deg;
+        g[2] = asinf ( R[2][0])             * rad2deg;
+        if (g[0] < 0)
+            g[0] += 360;
+
+        *outEvent = event;
+        outEvent->orientation.azimuth = g.x;
+        outEvent->orientation.pitch   = g.y;
+        outEvent->orientation.roll    = g.z;
+        outEvent->orientation.status  = SENSOR_STATUS_ACCURACY_HIGH;
+        outEvent->sensor = '_ypr';
+        outEvent->type = SENSOR_TYPE_ORIENTATION;
+        return true;
+    }
+    return false;
+}
+
+status_t LegacyOrientationSensor::activate(void* ident, bool enabled) {
+    if (enabled) {
+        mMagTime = 0;
+        mAccTime = 0;
+    }
+    return mSensorFusion.activate(FUSION_NOGYRO, ident, enabled);
+}
+
+status_t LegacyOrientationSensor::setDelay(void* ident, int /*handle*/, int64_t ns) {
+    return mSensorFusion.setDelay(FUSION_NOGYRO, ident, ns);
+}
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
diff --git a/services/sensorservice/legacy/LegacyOrientationSensor.h b/services/sensorservice/legacy/LegacyOrientationSensor.h
new file mode 100644
index 0000000..c8abd18
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyOrientationSensor.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_LEGACY_ORIENTATION_SENSOR_H
+#define ANDROID_LEGACY_ORIENTATION_SENSOR_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <gui/Sensor.h>
+
+#include "../SensorDevice.h"
+#include "../SensorInterface.h"
+
+#include "../Fusion.h"
+#include "../SensorFusion.h"
+#include "SecondOrderLowPassFilter.h"
+
+// ---------------------------------------------------------------------------
+namespace android {
+// ---------------------------------------------------------------------------
+
+class LegacyOrientationSensor : public VirtualSensor {
+    float mMagData[3];
+    double mAccTime;
+    double mMagTime;
+    SecondOrderLowPassFilter mALowPass;
+    CascadedBiquadFilter mAX, mAY, mAZ;
+    SecondOrderLowPassFilter mMLowPass;
+    CascadedBiquadFilter mMX, mMY, mMZ;
+
+public:
+    LegacyOrientationSensor();
+    virtual bool process(sensors_event_t* outEvent,
+            const sensors_event_t& event) override;
+    virtual status_t activate(void* ident, bool enabled) override;
+    virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
+};
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_LEGACY_ORIENTATION_SENSOR_H
diff --git a/services/sensorservice/legacy/LegacyRotationVectorSensor.cpp b/services/sensorservice/legacy/LegacyRotationVectorSensor.cpp
new file mode 100644
index 0000000..d82cb8e
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyRotationVectorSensor.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <math.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+
+#include <hardware/sensors.h>
+
+#include "LegacyRotationVectorSensor.h"
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+template <typename T>
+static inline T clamp(T v) {
+    return v < 0 ? 0 : v;
+}
+
+LegacyRotationVectorSensor::LegacyRotationVectorSensor()
+    : mALowPass(M_SQRT1_2, 1.5f),
+      mAX(mALowPass), mAY(mALowPass), mAZ(mALowPass),
+      mMLowPass(M_SQRT1_2, 1.5f),
+      mMX(mMLowPass), mMY(mMLowPass), mMZ(mMLowPass)
+{
+    const sensor_t sensor = {
+        .name       = "Rotation Vector Sensor",
+        .vendor     = "AOSP",
+        .version    = 3,
+        .handle     = '_rov',
+        .type       = SENSOR_TYPE_ROTATION_VECTOR,
+        .maxRange   = 1,
+        .resolution = 1.0f / (1<<24),
+        .power      = mSensorFusion.getPowerUsage(),
+        .minDelay   = mSensorFusion.getMinDelay(),
+    };
+    mSensor = Sensor(&sensor);
+}
+
+bool LegacyRotationVectorSensor::process(sensors_event_t* outEvent,
+        const sensors_event_t& event)
+{
+    const static double NS2S = 1.0 / 1000000000.0;
+    if (event.type == SENSOR_TYPE_MAGNETIC_FIELD) {
+        const double now = event.timestamp * NS2S;
+        if (mMagTime == 0) {
+            mMagData[0] = mMX.init(event.magnetic.x);
+            mMagData[1] = mMY.init(event.magnetic.y);
+            mMagData[2] = mMZ.init(event.magnetic.z);
+        } else {
+            double dT = now - mMagTime;
+            mMLowPass.setSamplingPeriod(dT);
+            mMagData[0] = mMX(event.magnetic.x);
+            mMagData[1] = mMY(event.magnetic.y);
+            mMagData[2] = mMZ(event.magnetic.z);
+        }
+        mMagTime = now;
+    }
+    if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+        const double now = event.timestamp * NS2S;
+        float Ax, Ay, Az;
+        if (mAccTime == 0) {
+            Ax = mAX.init(event.acceleration.x);
+            Ay = mAY.init(event.acceleration.y);
+            Az = mAZ.init(event.acceleration.z);
+        } else {
+            double dT = now - mAccTime;
+            mALowPass.setSamplingPeriod(dT);
+            Ax = mAX(event.acceleration.x);
+            Ay = mAY(event.acceleration.y);
+            Az = mAZ(event.acceleration.z);
+        }
+        mAccTime = now;
+        const float Ex = mMagData[0];
+        const float Ey = mMagData[1];
+        const float Ez = mMagData[2];
+        float Hx = Ey*Az - Ez*Ay;
+        float Hy = Ez*Ax - Ex*Az;
+        float Hz = Ex*Ay - Ey*Ax;
+        const float normH = sqrtf(Hx*Hx + Hy*Hy + Hz*Hz);
+        if (normH < 0.1f) {
+            // device is close to free fall (or in space?), or close to
+            // magnetic north pole. Typical values are  > 100.
+            return false;
+        }
+        const float invH = 1.0f / normH;
+        const float invA = 1.0f / sqrtf(Ax*Ax + Ay*Ay + Az*Az);
+        Hx *= invH;
+        Hy *= invH;
+        Hz *= invH;
+        Ax *= invA;
+        Ay *= invA;
+        Az *= invA;
+        const float Mx = Ay*Hz - Az*Hy;
+        const float My = Az*Hx - Ax*Hz;
+        //const float Mz = Ax*Hy - Ay*Hx;
+
+        // construct real rotation matrix
+        mat33_t R;
+        R[0].x = Hx;
+        R[0].y = Hy;
+        R[0].z = Hz;
+        R[1].x = Mx;
+        R[1].y = My;
+        R[2].x = Ax;
+        R[2].y = Ay;
+        R[2].z = Az;
+
+        vec4_t q = matrixToQuat(R);
+
+        *outEvent = event;
+        outEvent->data[0] = q.x;
+        outEvent->data[1] = q.y;
+        outEvent->data[2] = q.z;
+        outEvent->data[3] = q.w;
+        outEvent->sensor = '_rov';
+        outEvent->type = SENSOR_TYPE_ROTATION_VECTOR;
+        return true;
+    }
+    return false;
+}
+
+status_t LegacyRotationVectorSensor::activate(void* ident, bool enabled) {
+    if (enabled) {
+        mMagTime = 0;
+        mAccTime = 0;
+    }
+    return mSensorFusion.activate(FUSION_NOGYRO, ident, enabled);
+}
+
+status_t LegacyRotationVectorSensor::setDelay(void* ident, int /*handle*/, int64_t ns) {
+    return mSensorFusion.setDelay(FUSION_NOGYRO, ident, ns);
+}
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
diff --git a/services/sensorservice/legacy/LegacyRotationVectorSensor.h b/services/sensorservice/legacy/LegacyRotationVectorSensor.h
new file mode 100644
index 0000000..8d0e999
--- /dev/null
+++ b/services/sensorservice/legacy/LegacyRotationVectorSensor.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_LEGACY_ROTATION_VECTOR_SENSOR_H
+#define ANDROID_LEGACY_ROTATION_VECTOR_SENSOR_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <gui/Sensor.h>
+
+#include "../SensorDevice.h"
+#include "../SensorInterface.h"
+
+#include "../Fusion.h"
+#include "../SensorFusion.h"
+#include "SecondOrderLowPassFilter.h"
+
+// ---------------------------------------------------------------------------
+namespace android {
+// ---------------------------------------------------------------------------
+
+class LegacyRotationVectorSensor : public VirtualSensor {
+    float mMagData[3];
+    double mAccTime;
+    double mMagTime;
+    SecondOrderLowPassFilter mALowPass;
+    CascadedBiquadFilter mAX, mAY, mAZ;
+    SecondOrderLowPassFilter mMLowPass;
+    CascadedBiquadFilter mMX, mMY, mMZ;
+
+public:
+    LegacyRotationVectorSensor();
+    virtual bool process(sensors_event_t* outEvent,
+            const sensors_event_t& event) override;
+    virtual status_t activate(void* ident, bool enabled) override;
+    virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
+};
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_LEGACY_ROTATION_VECTOR_SENSOR_H
diff --git a/services/sensorservice/legacy/SecondOrderLowPassFilter.cpp b/services/sensorservice/legacy/SecondOrderLowPassFilter.cpp
new file mode 100644
index 0000000..eeb6d1e
--- /dev/null
+++ b/services/sensorservice/legacy/SecondOrderLowPassFilter.cpp
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <math.h>
+
+#include <cutils/log.h>
+
+#include "SecondOrderLowPassFilter.h"
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+SecondOrderLowPassFilter::SecondOrderLowPassFilter(float Q, float fc)
+    : iQ(1.0f / Q), fc(fc)
+{
+}
+
+void SecondOrderLowPassFilter::setSamplingPeriod(float dT)
+{
+    K = tanf(float(M_PI) * fc * dT);
+    iD = 1.0f / (K*K + K*iQ + 1);
+    a0 = K*K*iD;
+    a1 = 2.0f * a0;
+    b1 = 2.0f*(K*K - 1)*iD;
+    b2 = (K*K - K*iQ + 1)*iD;
+}
+
+// ---------------------------------------------------------------------------
+
+BiquadFilter::BiquadFilter(const SecondOrderLowPassFilter& s)
+    : s(s)
+{
+}
+
+float BiquadFilter::init(float x)
+{
+    x1 = x2 = x;
+    y1 = y2 = x;
+    return x;
+}
+
+float BiquadFilter::operator()(float x)
+{
+    float y = (x + x2)*s.a0 + x1*s.a1 - y1*s.b1 - y2*s.b2;
+    x2 = x1;
+    y2 = y1;
+    x1 = x;
+    y1 = y;
+    return y;
+}
+
+// ---------------------------------------------------------------------------
+
+CascadedBiquadFilter::CascadedBiquadFilter(const SecondOrderLowPassFilter& s)
+    : mA(s), mB(s)
+{
+}
+
+float CascadedBiquadFilter::init(float x)
+{
+    mA.init(x);
+    mB.init(x);
+    return x;
+}
+
+float CascadedBiquadFilter::operator()(float x)
+{
+    return mB(mA(x));
+}
+
+// ---------------------------------------------------------------------------
+}; // namespace android
diff --git a/services/sensorservice/legacy/SecondOrderLowPassFilter.h b/services/sensorservice/legacy/SecondOrderLowPassFilter.h
new file mode 100644
index 0000000..85698ca
--- /dev/null
+++ b/services/sensorservice/legacy/SecondOrderLowPassFilter.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SECOND_ORDER_LOW_PASS_FILTER_H
+#define ANDROID_SECOND_ORDER_LOW_PASS_FILTER_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+// ---------------------------------------------------------------------------
+
+class BiquadFilter;
+
+/*
+ * State of a 2nd order low-pass IIR filter
+ */
+class SecondOrderLowPassFilter {
+    friend class BiquadFilter;
+    float iQ, fc;
+    float K, iD;
+    float a0, a1;
+    float b1, b2;
+public:
+    SecondOrderLowPassFilter(float Q, float fc);
+    void setSamplingPeriod(float dT);
+};
+
+/*
+ * Implements a Biquad IIR filter
+ */
+class BiquadFilter {
+    float x1, x2;
+    float y1, y2;
+    const SecondOrderLowPassFilter& s;
+public:
+    BiquadFilter(const SecondOrderLowPassFilter& s);
+    float init(float in);
+    float operator()(float in);
+};
+
+/*
+ * Two cascaded biquad IIR filters
+ * (4-poles IIR)
+ */
+class CascadedBiquadFilter {
+    BiquadFilter mA;
+    BiquadFilter mB;
+public:
+    CascadedBiquadFilter(const SecondOrderLowPassFilter& s);
+    float init(float in);
+    float operator()(float in);
+};
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_SECOND_ORDER_LOW_PASS_FILTER_H
-- 
2.7.4

