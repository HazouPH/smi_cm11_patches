From 852219464f42f4031eaba1edd3f68c74e030eb92 Mon Sep 17 00:00:00 2001
From: Chen Bin <bin.chen@intel.com>
Date: Mon, 15 Apr 2013 10:51:18 +0800
Subject: [PATCH 2/8] [PATCH] [PORT FROM MAIN]Let the dequeue buffer not busy
 wait

UI thread and Surfaceflinger Thread are in the same process. They have race to map the
same buffer. and may cause Dequeue buffer failed.
Then UI thread will busy wait for dequeue buffer condition for ever, system will always
black screen.
This Patch don't let UI thread busy wait, and free all buffer to let system can recover.

Change-Id: Ia8e8be40ca229b52e7003d49970986f18e89fded
Category: aosp improvement
Domain: Graphics.UI
Origin: internal
Signed-off-by: Shi Yang <yang.a.shi@intel.com>
Signed-off-by: yifeix.xue <yifeix.xue@intel.com>
Signed-off-by: binchen1 <bin.chen@intel.com>
---
 libs/gui/BufferQueue.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index f7b1bee..b52185f 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -33,6 +33,8 @@
 #include <utils/Trace.h>
 #include <utils/CallStack.h>
 
+static const nsecs_t DEQUEUE_TIMEOUT_VALUE = seconds(3);
+
 #include <binder/IPCThreadState.h>
 #include <binder/PermissionCache.h>
 #include <private/android_filesystem_config.h>
@@ -381,7 +383,10 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async
                     ST_LOGE("dequeueBuffer: would block! returning an error instead.");
                     return WOULD_BLOCK;
                 }
-                mDequeueCondition.wait(mMutex);
+                if (mDequeueCondition.waitRelative(mMutex, DEQUEUE_TIMEOUT_VALUE)) {
+                    ST_LOGE("dequeueBuffer: time out and will free all buffer!");
+                    freeAllBuffersLocked();
+                }
             }
         }
 
-- 
2.7.4

