From: Intel

Let the dequeue buffer not busy wait

UI thread and Surfaceflinger Thread are in the same process. They have race to map the
same buffer. and may cause Dequeue buffer failed.
Then UI thread will busy wait for dequeue buffer condition for ever, system will always
black screen.
This Patch don't let UI thread busy wait, and free all buffer to let system can recover.

diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index 146f534..decbfd3 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -33,6 +33,8 @@
 #include <utils/Trace.h>
 #include <utils/CallStack.h>
 
+static const nsecs_t DEQUEUE_TIMEOUT_VALUE = seconds(3);
+
 // Macros for including the BufferQueue name in log messages
 #define ST_LOGV(x, ...) ALOGV("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
 #define ST_LOGD(x, ...) ALOGD("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
@@ -377,7 +379,10 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async
                     ST_LOGE("dequeueBuffer: would block! returning an error instead.");
                     return WOULD_BLOCK;
                 }
-                mDequeueCondition.wait(mMutex);
+                if (mDequeueCondition.waitRelative(mMutex, DEQUEUE_TIMEOUT_VALUE)) {
+                    ST_LOGE("dequeueBuffer: time out and will free all buffer!");
+                    freeAllBuffersLocked();
+                }
             }
         }
 
