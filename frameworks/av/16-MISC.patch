From: Geekphone

MISC changes: Samplingrate, HEVC, CameraShutter sound, Dynamic resolution


diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index d1b4381..fec245b 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -2490,11 +2490,15 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         sampleRate = br.getBits(24);
         numChannels = br.getBits(4);
     } else {
-        numChannels = br.getBits(4);
-
         if (freqIndex == 13 || freqIndex == 14) {
             return ERROR_MALFORMED;
         }
+        numChannels = br.getBits(4);
+        sampleRate = kSamplingRate[freqIndex];
+    }
+    if (objectType == 5 || objectType == 29) {
+        // SBR specific config per 14496-3 table 1.13
+        freqIndex = br.getBits(4);
 
         sampleRate = kSamplingRate[freqIndex];
     }
@@ -3831,6 +3831,7 @@ status_t MPEG4Source::fragmentedRead(
             mBuffer->set_range(0, dstOffset);
         }
 
+        mBuffer->meta_data()->clear();
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
 
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 1546a7e..3e8021d 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -1108,6 +1108,9 @@ static void StripStartcode(MediaBuffer *buffer) {
     if (!memcmp(ptr, "\x00\x00\x00\x01", 4)) {
         buffer->set_range(
                 buffer->range_offset() + 4, buffer->range_length() - 4);
+    } else {
+        //nal length prefixed
+        return;
     }
 #endif
 }
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 269028a..0f58d48 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -601,6 +605,9 @@ sp<MediaSource> OMXCodec::Create(
 
             err = codec->configureCodec(meta);
             if (err == OK) {
+                if (!strncmp("OMX.Intel.VideoEncoder", componentName, 22)) {
+                    codec->mFlags &= ~kOnlySubmitOneInputBufferAtOneTime;
+                }
                 return codec;
             }
 
@@ -2608,15 +2620,9 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         cancelEnd = def.nBufferCountActual;
     }
 
-
-    if (err != 0 &&
-        ((mState == LOADED) || (mState == LOADED_TO_IDLE))) {
-        freeBuffersOnPort(kPortIndexOutput);
-    } else {
-        for (OMX_U32 i = cancelStart; i < cancelEnd; i++) {
-            BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(i);
-            cancelBufferToNativeWindow(info);
-        }
+    for (OMX_U32 i = cancelStart; i < cancelEnd; i++) {
+        BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(i);
+        cancelBufferToNativeWindow(info);
     }
 
     return err;
@@ -3193,6 +3212,7 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
                 // when the OMX_EventPortSettingsChanged is not meant for reallocating
                 // the output buffers.
                 if (data1 == kPortIndexOutput) {
+                    mFilledBuffers.clear();
                     CHECK(mFilledBuffers.empty());
                 }
                 onPortSettingsChanged(data1);
@@ -3807,7 +3827,8 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
         size_t size = specific->mSize;
 
-        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME)
+        if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME) ||
+             !strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mMIME))
                 && !(mQuirks & kWantsNALFragments)) {
             static const uint8_t kNALStartCode[4] =
                     { 0x00, 0x00, 0x00, 0x01 };
@@ -5486,6 +5507,12 @@ void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
         BufferInfo *info = &buffers->editItemAt(i);
 
         if (info->mMediaBuffer == buffer) {
+            if (mPortStatus[kPortIndexOutput] == DISABLING) {
+                CODEC_LOGV("Port is disabled, freeing buffer %p", buffer);
+                status_t err = freeBuffer(kPortIndexOutput, i);
+                CHECK_EQ(err, (status_t)OK);
+                return;
+            }
             CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)ENABLED);
             CHECK_EQ((int)info->mStatus, (int)OWNED_BY_CLIENT);
 
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 994ce26..beb6126 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -883,6 +883,7 @@ MediaPlayer* CameraService::newMediaPlayer(const char *file) {
         mp->prepare();
     } else {
         ALOGE("Failed to load CameraService sounds: %s", file);
+        delete mp;
         return NULL;
     }
     return mp;
@@ -1185,6 +1186,7 @@ status_t CameraService::dump(int fd, const Vector<String16>& args) {
         if (!mModule) {
             result = String8::format("No camera module available!\n");
             write(fd, result.string(), result.size());
+            if (locked) mServiceLock.unlock();
             return NO_ERROR;
         }
 
diff --git a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
index b093946..9d95eb4 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.cpp
+++ b/services/camera/libcameraservice/api1/Camera2Client.cpp
@@ -406,6 +406,12 @@ void Camera2Client::disconnect() {
         l.mParameters.state = Parameters::DISCONNECTED;
     }
 
+    mStreamingProcessor->deletePreviewStream();
+    mStreamingProcessor->deleteRecordingStream();
+    mJpegProcessor->deleteStream();
+    mCallbackProcessor->deleteStream();
+    mZslProcessor->deleteStream();
+
     mStreamingProcessor->requestExit();
     mFrameProcessor->requestExit();
     mCaptureSequencer->requestExit();
@@ -832,6 +838,18 @@ status_t Camera2Client::startPreviewL(Parameters &params, bool restart) {
         res = mStreamingProcessor->startStream(StreamingProcessor::PREVIEW,
                 outputStreams);
     } else {
+        // With recording hint set, we're going to be operating under the
+        // assumption that the user will record video. To optimize recording
+        // startup time, create the necessary output streams for recording and
+        // video snapshot now if they don't already exist.
+        res = mJpegProcessor->updateStream(params);
+        if (res != OK) {
+            ALOGE("%s: Camera %d: Can't pre-configure still image "
+                    "stream: %s (%d)",
+                    __FUNCTION__, mCameraId, strerror(-res), res);
+            return res;
+        }
+
         if (!restart) {
             res = mStreamingProcessor->updateRecordingRequest(params);
             if (res != OK) {
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 1629e05..0204fbd 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -368,6 +368,7 @@ status_t CameraClient::startPreview() {
 status_t CameraClient::startRecording() {
     Mutex::Autolock lock(mLock);
     LOG1("startRecording (pid %d)", getCallingPid());
+    disableMsgType(CAMERA_MSG_SHUTTER);
     return startCameraMode(CAMERA_RECORDING_MODE);
 }
 
diff --git a/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp b/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
index 6076dae..8f20bfe 100644
--- a/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
+++ b/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
@@ -733,6 +733,9 @@ void StreamingProcessor::releaseRecordingFrame(const sp<IMemory>& mem) {
     ATRACE_CALL();
     status_t res;
 
+    sp<Camera2Client> client = mClient.promote();
+    if (client == 0) return;
+
     Mutex::Autolock m(mMutex);
     // Make sure this is for the current heap
     ssize_t offset;
diff --git a/services/camera/libcameraservice/device1/CameraHardwareInterface.h b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
index 7e71c87..ac80c23 100644
--- a/services/camera/libcameraservice/device1/CameraHardwareInterface.h
+++ b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
@@ -111,6 +111,11 @@ public:
         ALOGV("%s(%s) buf %p", __FUNCTION__, mName.string(), buf.get());
 
         if (mDevice->ops->set_preview_window) {
+            if (buf.get() == NULL) {
+                int ret = mDevice->ops->set_preview_window(mDevice, 0);
+                mPreviewWindow = buf;
+                return ret;
+            }
             mPreviewWindow = buf;
             mHalPreviewWindow.user = this;
             ALOGV("%s &mHalPreviewWindow %p mHalPreviewWindow.user %p", __FUNCTION__,
