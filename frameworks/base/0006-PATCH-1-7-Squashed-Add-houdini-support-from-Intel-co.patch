From e4ef32844b902cae49f6b3227c9c7303b203032a Mon Sep 17 00:00:00 2001
From: Patrick Harbers <jgrharbers@gmail.com>
Date: Tue, 29 Mar 2016 01:22:14 +0200
Subject: [PATCH 06/12] [PATCH 1/7] [Squashed] Add houdini support from Intel
 commits

Change-Id: I8bdf247a075912d63b054b088a44fa1e252cb7d5
---
 cmds/app_process/app_main.cpp                      |  40 +++
 core/java/android/content/pm/PackageManager.java   |  17 +
 core/java/android/os/Build.java                    |  14 +
 .../internal/content/NativeLibraryHelper.java      | 176 ++++++++++-
 core/java/com/android/internal/os/CheckExt.java    |  46 +++
 core/java/com/android/internal/os/ICheckExt.java   |  30 ++
 .../com/android/internal/os/ZygoteConnection.java  |  27 ++
 core/java/com/android/internal/os/ZygoteInit.java  |   7 +
 core/java/com/android/internal/os/xmlCheckExt.java | 123 ++++++++
 core/jni/Android.mk                                |   7 +
 core/jni/AndroidRuntime.cpp                        |   6 +
 core/jni/android_app_NativeActivity.cpp            |  45 ++-
 ...ndroid_internal_content_NativeLibraryHelper.cpp | 341 ++++++++++++++++++++-
 .../com_android_internal_os_ZygoteConnection.cpp   | 113 +++++++
 core/jni/com_android_internal_os_ZygoteInit.cpp    |  17 +-
 .../defcontainer/DefaultContainerService.java      |  20 +-
 .../android/server/pm/PackageManagerService.java   | 188 +++++++++++-
 17 files changed, 1199 insertions(+), 18 deletions(-)
 create mode 100644 core/java/com/android/internal/os/CheckExt.java
 create mode 100644 core/java/com/android/internal/os/ICheckExt.java
 create mode 100644 core/java/com/android/internal/os/xmlCheckExt.java
 create mode 100644 core/jni/com_android_internal_os_ZygoteConnection.cpp
 mode change 100644 => 100755 services/java/com/android/server/pm/PackageManagerService.java

diff --git a/cmds/app_process/app_main.cpp b/cmds/app_process/app_main.cpp
index cb27c5b..d45f476 100644
--- a/cmds/app_process/app_main.cpp
+++ b/cmds/app_process/app_main.cpp
@@ -16,6 +16,8 @@
 #include <cutils/trace.h>
 #include <android_runtime/AndroidRuntime.h>
 #include <sys/personality.h>
+#include <sys/utsname.h>
+#include <sys/resource.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -164,6 +166,44 @@ int main(int argc, char* const argv[])
     unsetenv("NO_ADDR_COMPAT_LAYOUT_FIXUP");
 #endif
 
+#ifdef __i386__
+    struct utsname u_name;
+    if (uname(&u_name) == -1) {
+        fprintf(stderr, "Error: uname call failed.\n");
+    } else {
+        char value[PROPERTY_VALUE_MAX];
+        int ret;
+        ret = property_get("ro.config.personality", value, "");
+        if (ret && !strcmp(value, "compat_layout")
+                && (getenv("NO_ADDR_COMPAT_LAYOUT_FIXUP") == NULL)) {
+            int old_personality;
+            old_personality = personality((unsigned long)-1);
+            if (!strcmp(u_name.machine, "x86_64")
+                    && !(old_personality & ADDR_LIMIT_3GB)) {
+                /* In zygote, set stack limit to force mmap/heap area initially
+                 * below 2G, so as to workaround buggy applications that assume
+                 * positive memory address.
+                 * NOTE: A 64bit kernel allows either a 3G or 4G user space for
+                 * a 32bit application. In the case of a 3G user address space,
+                 * the 0x90000000 magic number is incorrect and Houdini apps
+                 * may fail, but tuning has shown it generally allows Houdini
+                 * apps to run successfully.
+                 */
+                struct rlimit rlim;
+                rlim.rlim_max = rlim.rlim_cur = 0x90000000;
+                int res = 0;
+                res = setrlimit(RLIMIT_STACK, &rlim);
+            } else {
+                personality(old_personality | ADDR_COMPAT_LAYOUT);
+            }
+            setenv("NO_ADDR_COMPAT_LAYOUT_FIXUP", "1", 1);
+            execv("/system/bin/app_process", argv);
+            return -1;
+        }
+        unsetenv("NO_ADDR_COMPAT_LAYOUT_FIXUP");
+    }
+#endif
+
     // These are global variables in ProcessState.cpp
     mArgC = argc;
     mArgV = argv;
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index d21692e..13114e6 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -370,6 +370,23 @@ public abstract class PackageManager {
     public static final int INSTALL_SUCCEEDED = 1;
 
     /**
+     * Native Library Copy return code: this is passed to {@link PackageManagerService} by
+     * {@link NativeLibararyHelper} on successful copy of native library.
+     * It indicates that the native library being copied matches 2nd ABI.
+     * @hide
+     */
+
+    public static final int INSTALL_ABI2_SUCCEEDED = 2;
+
+    /**
+     * Native Library Copy return code: this is passed to {@link PackageManagerService} by
+     * {@link NativeLibararyHelper} on package with x86 lib in the assets folder.
+     * @hide
+     */
+
+    public static final int INSTALL_IMPLICIT_ABI_SUCCEEDED = 4;
+
+    /**
      * Installation return code: this is passed to the {@link IPackageInstallObserver} by
      * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)} if the package is
      * already installed.
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index 16b2b67..ee82d62 100644
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -46,6 +46,20 @@ public class Build {
     /** The name of the second instruction set (CPU type + ABI convention) of native code. */
     public static final String CPU_ABI2 = getString("ro.product.cpu.abi2");
 
+    /**
+     * The name of instruction set 1 (CPU type + ABI convention) for Houdini app.
+     *
+     * @hide
+     */
+    public static final String HOUDINI_ABI = "armeabi-v7a";
+
+    /**
+     * The name of instruction set 2 (CPU type + ABI convention) for Houdini app.
+     *
+     * @hide
+     */
+    public static final String HOUDINI_ABI2 = "armeabi";
+
     /** The manufacturer of the product/hardware. */
     public static final String MANUFACTURER = getString("ro.product.manufacturer");
 
diff --git a/core/java/com/android/internal/content/NativeLibraryHelper.java b/core/java/com/android/internal/content/NativeLibraryHelper.java
index 6d65782..e59c833 100644
--- a/core/java/com/android/internal/content/NativeLibraryHelper.java
+++ b/core/java/com/android/internal/content/NativeLibraryHelper.java
@@ -16,11 +16,17 @@
 
 package com.android.internal.content;
 
+import android.content.pm.PackageManager;
+import android.content.pm.PackageParser;
+import android.content.pm.PackageParser.PackageLite;
 import android.os.Build;
+import android.os.SystemProperties;
 import android.util.Slog;
 
-import java.io.File;
+import com.android.internal.os.CheckExt;
+import com.android.internal.os.ICheckExt;
 
+import java.io.File;
 /**
  * Native libraries helper.
  *
@@ -42,9 +48,101 @@ public class NativeLibraryHelper {
     public static long sumNativeBinariesLI(File apkFile) {
         final String cpuAbi = Build.CPU_ABI;
         final String cpuAbi2 = Build.CPU_ABI2;
-        return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+        String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+
+        if (abi2.length() != 0) {
+            final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi",
+                    "armeabi");
+            final int INSTALL_ABI_SUCCEEDED = 99;
+            final int INSTALL_MISMATCH_ABI2_SUCCEEDED = 100;
+            final int INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED = 101;
+            final int INSTALL_UPGRADEABI_SUCCEEDED = 102;
+
+            int result = nativeListNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2, abiUpgrade);
+            switch(result) {
+                case INSTALL_MISMATCH_ABI2_SUCCEEDED:
+                case INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED:
+                    // workaround to handle lib mismatch cases
+                    ICheckExt check = new CheckExt();
+                    String pkgName = getPackageName(apkFile.getPath());
+                    if (check.doCheck(pkgName, new String("white"))) {
+                        return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi);
+                    } else {
+                        if (result == INSTALL_MISMATCH_ABI2_SUCCEEDED) {
+                            return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi2, cpuAbi2);
+                        } else {
+                            return nativeSumNativeBinaries(apkFile.getPath(), abiUpgrade,
+                                    abiUpgrade);
+                        }
+                    }
+                case PackageManager.INSTALL_ABI2_SUCCEEDED:
+                    return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi2, cpuAbi2);
+                case INSTALL_UPGRADEABI_SUCCEEDED:
+                    return nativeSumNativeBinaries(apkFile.getPath(), abiUpgrade, abiUpgrade);
+                case INSTALL_ABI_SUCCEEDED:
+                    return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi);
+                default:
+                    return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+            }
+        } else {
+            return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+        }
+    }
+    private static native int nativeListNativeBinaries(String file, String cpuAbi,
+            String cpuAbi2, String upgradeAbi);
+
+    /**
+     * List the native binaries info in an APK.
+     *
+     * @param apkFile APK file to scan for native libraries
+     * @return {@link PackageManager#INSTALL_SUCCEEDED} or
+             {@link PackageManager#INSTALL_ABI2_SUCCEEDED}
+     *         or another error code from that class if not
+     */
+    public static int listNativeBinariesLI(File apkFile, String pkgName) {
+        final String cpuAbi = Build.CPU_ABI;
+        final String cpuAbi2 = Build.CPU_ABI2;
+        String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+
+        if (abi2.length() != 0) {
+            final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi",
+                    "armeabi");
+            final int INSTALL_ABI_SUCCEEDED = 99;
+            final int INSTALL_MISMATCH_ABI2_SUCCEEDED = 100;
+            final int INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED = 101;
+            final int INSTALL_UPGRADEABI_SUCCEEDED = 102;
+            final int INSTALL_IMPLICIT_ABI2_SUCCEEDED = 103;
+            final int INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED = 104;
+
+
+            int result = nativeListNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2, abiUpgrade);
+            switch(result) {
+                case INSTALL_MISMATCH_ABI2_SUCCEEDED:
+                case INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED:
+                    // workaround to handle lib mismatch cases
+                    ICheckExt check = new CheckExt();
+                    if (check.doCheck(pkgName, new String("white"))) {
+                        return PackageManager.INSTALL_SUCCEEDED;
+                    } else {
+                        return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                    }
+                case PackageManager.INSTALL_ABI2_SUCCEEDED:
+                case INSTALL_UPGRADEABI_SUCCEEDED:
+                    return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                case INSTALL_ABI_SUCCEEDED:
+                    return PackageManager.INSTALL_SUCCEEDED;
+                case INSTALL_IMPLICIT_ABI2_SUCCEEDED:
+                case INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED:
+                    return PackageManager.INSTALL_IMPLICIT_ABI_SUCCEEDED;
+                default:
+                    return result;
+            }
+        } else {
+            return PackageManager.INSTALL_SUCCEEDED;
+        }
     }
 
+
     private native static int nativeCopyNativeBinaries(String filePath, String sharedLibraryPath,
             String cpuAbi, String cpuAbi2);
 
@@ -53,14 +151,75 @@ public class NativeLibraryHelper {
      *
      * @param apkFile APK file to scan for native libraries
      * @param sharedLibraryDir directory for libraries to be copied to
-     * @return {@link PackageManager#INSTALL_SUCCEEDED} if successful or another
+     * @return {@link PackageManager#INSTALL_SUCCEEDED} or
+             {@link PackageManager#INSTALL_ABI2_SUCCEEDED}
+     *         if successful or another error code from that class if not
      *         error code from that class if not
      */
     public static int copyNativeBinariesIfNeededLI(File apkFile, File sharedLibraryDir) {
         final String cpuAbi = Build.CPU_ABI;
         final String cpuAbi2 = Build.CPU_ABI2;
-        return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi,
-                cpuAbi2);
+        String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+
+        if (abi2.length() != 0) {
+            final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi",
+                    "armeabi");
+            final int INSTALL_ABI_SUCCEEDED = 99;
+            final int INSTALL_MISMATCH_ABI2_SUCCEEDED = 100;
+            final int INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED = 101;
+            final int INSTALL_UPGRADEABI_SUCCEEDED = 102;
+            final int INSTALL_IMPLICIT_ABI2_SUCCEEDED = 103;
+            final int INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED = 104;
+
+            int result = nativeListNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2, abiUpgrade);
+            switch(result) {
+                case INSTALL_MISMATCH_ABI2_SUCCEEDED:
+                case INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED:
+                    // workaround to handle lib mismatch cases
+                    String pkgName = getPackageName(apkFile.getPath());
+                    ICheckExt check = new CheckExt();
+                    if (check.doCheck(pkgName, new String("white"))) {
+                        nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                                cpuAbi, cpuAbi);
+                        return PackageManager.INSTALL_SUCCEEDED;
+                    } else {
+                        if (result == INSTALL_MISMATCH_ABI2_SUCCEEDED) {
+                            nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                                    cpuAbi2, cpuAbi2);
+                        } else {
+                            nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                                    abiUpgrade, abiUpgrade);
+                        }
+                        return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                    }
+                case PackageManager.INSTALL_ABI2_SUCCEEDED:
+                    nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            cpuAbi2, cpuAbi2);
+                    return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                case INSTALL_UPGRADEABI_SUCCEEDED:
+                    nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            abiUpgrade, abiUpgrade);
+                    return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                case INSTALL_ABI_SUCCEEDED:
+                    nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            cpuAbi, cpuAbi);
+                    return PackageManager.INSTALL_SUCCEEDED;
+                case INSTALL_IMPLICIT_ABI2_SUCCEEDED:
+                    nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            cpuAbi2, cpuAbi2);
+                    return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                case INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED:
+                    nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            abiUpgrade, abiUpgrade);
+                    return PackageManager.INSTALL_ABI2_SUCCEEDED;
+                default:
+                    return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                            cpuAbi, cpuAbi2);
+            }
+        } else {
+            return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(),
+                    cpuAbi, cpuAbi2);
+        }
     }
 
     // Convenience method to call removeNativeBinariesFromDirLI(File)
@@ -103,4 +262,11 @@ public class NativeLibraryHelper {
 
         return deletedFiles;
     }
+
+    private static String getPackageName(String packageFilePath) {
+        PackageLite pkg = PackageParser.parsePackageLite(packageFilePath, 0);
+        if (pkg != null)
+            return pkg.packageName;
+        return null;
+    }
 }
diff --git a/core/java/com/android/internal/os/CheckExt.java b/core/java/com/android/internal/os/CheckExt.java
new file mode 100644
index 0000000..bb1f07d
--- /dev/null
+++ b/core/java/com/android/internal/os/CheckExt.java
@@ -0,0 +1,46 @@
+package com.android.internal.os;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.ArrayList;
+
+/*
+ * class CheckExt is trying to check params
+ */
+public class CheckExt implements ICheckExt {
+    final private String TAG = "CheckExt";
+    private List<ICheckExt> checklist;
+
+    public CheckExt() {
+        checklist = new ArrayList<ICheckExt>();
+        ICheckExt check = new xmlCheckExt();
+        checklist.add(check);
+    }
+
+    public boolean doCheck(String... params) {
+        if (checklist.size() == 0)
+            return false;
+        ICheckExt check;
+        for (int i = 0; i < checklist.size(); i++) {
+            check = checklist.get(i);
+            if (check.doCheck(params))
+                return true;
+
+        }
+        return false;
+    }
+}
diff --git a/core/java/com/android/internal/os/ICheckExt.java b/core/java/com/android/internal/os/ICheckExt.java
new file mode 100644
index 0000000..ab24059
--- /dev/null
+++ b/core/java/com/android/internal/os/ICheckExt.java
@@ -0,0 +1,30 @@
+package com.android.internal.os;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface ICheckExt {
+
+    /*Function: doCheck
+     *Description:
+     * check parameters to decide whether it should pass or not
+     *Parameter:
+     * params : parameters for apk to check
+     *Return:
+     * true - check pass
+     * false - check fail
+     */
+    boolean doCheck(String... params);
+}
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index f5abacf..f9d85ea 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -19,9 +19,11 @@ package com.android.internal.os;
 import android.graphics.Typeface;
 import android.net.Credentials;
 import android.net.LocalSocket;
+import android.os.Build;
 import android.os.Process;
 import android.os.SELinux;
 import android.os.SystemProperties;
+import android.os.UserHandle;
 import android.util.Log;
 
 import dalvik.system.PathClassLoader;
@@ -78,6 +80,14 @@ class ZygoteConnection {
 
     private static final int GC_LOOP_COUNT = 10;
 
+    private static final int APP_ABI2_FLAG = 1;
+    private static final int APP_IMPLICIT_ABI_FLAG = 2;
+
+    private native int isABI2App(int uid);
+    private native void settingHoudiniABI();
+    private native void unloadHoudini();
+    String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+
     /**
      * Constructs instance from connected socket.
      *
@@ -275,6 +285,23 @@ class ZygoteConnection {
                 // in child
                 IoUtils.closeQuietly(serverPipeFd);
                 serverPipeFd = null;
+                if (abi2.length() != 0) {
+                    int ret = isABI2App(UserHandle.getAppId(parsedArgs.uid));
+                    // Log.d(TAG, "isABI2App return " + ret);
+                    if ((ret & APP_ABI2_FLAG) == APP_ABI2_FLAG) {
+                        ICheckExt check = new CheckExt();
+                        if (!check.doCheck(parsedArgs.niceName, new String("arch"))
+                                && ((ret & APP_IMPLICIT_ABI_FLAG) == 0)) {
+                            System.setProperty("os.arch", "armv7l");
+                            Log.d(TAG, "Setting os.arch");
+                            settingHoudiniABI();
+                        } else {
+                            Log.d(TAG, "Keeping os.arch: " + parsedArgs.niceName);
+                        }
+                    } else {
+                        unloadHoudini();
+                    }
+                }
                 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);
 
                 // should never get here, the child is expected to either
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 671846e..a0e3c2a 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -23,6 +23,7 @@ import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.net.LocalServerSocket;
 import android.opengl.EGL14;
+import android.os.Build;
 import android.os.Debug;
 import android.os.Process;
 import android.os.SystemClock;
@@ -524,7 +525,10 @@ public class ZygoteInit {
         return result;
     }
 
+    static native void preloadHoudini();
+
     public static void main(String argv[]) {
+        String abi2 = SystemProperties.get("ro.product.cpu.abi2");
         try {
             // Start profiling the zygote initialization.
             SamplingProfilerIntegration.start();
@@ -559,6 +563,9 @@ public class ZygoteInit {
 
             Log.i(TAG, "Accepting command socket connections");
 
+            if (abi2.length() != 0)
+                preloadHoudini();
+
             runSelectLoop();
 
             closeServerSocket();
diff --git a/core/java/com/android/internal/os/xmlCheckExt.java b/core/java/com/android/internal/os/xmlCheckExt.java
new file mode 100644
index 0000000..b3d5f4d
--- /dev/null
+++ b/core/java/com/android/internal/os/xmlCheckExt.java
@@ -0,0 +1,123 @@
+package com.android.internal.os;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.List;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.app.Activity;
+import android.content.res.AssetManager;
+import android.util.Log;
+import android.util.Xml;
+
+/*
+ * class xmlCheckExt is trying to check by xml rules definition
+ */
+public class xmlCheckExt implements ICheckExt {
+    final private String TAG = "xmlCheckExt";
+    final private String CHECKXMLPATH = "/system/lib/arm/check.knobs";
+    private HashMap<String,String > mMap = new  HashMap<String,String >();
+
+    public boolean doCheck(String... params) {
+        String param = null;
+        String param_tag = null;
+        InputStream in = null;
+        try {
+            int eventType;
+            String tag;
+            if (params.length == 0)
+                return false;
+            param = params[0];
+            param_tag = params[1];
+            XmlPullParser xmlParser = Xml.newPullParser();
+            File file = new File(CHECKXMLPATH);
+            if (!file.exists())
+                return false;
+            in = new FileInputStream(file);
+            xmlParser.setInput(in, "utf-8");
+
+            eventType = xmlParser.getEventType();
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                switch (eventType) {
+                    case XmlPullParser.START_TAG:
+                        tag = xmlParser.getName();
+                        Log.d(TAG,"<"+tag+">");
+                        addTag(tag, xmlParser.nextText());
+                        break;
+                    case XmlPullParser.END_TAG:
+                        tag = xmlParser.getName();
+                        Log.d(TAG,"</"+tag+">");
+                        break;
+                    default:
+                        break;
+                }
+                eventType = xmlParser.next();
+            }
+        } catch (XmlPullParserException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (FileNotFoundException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+
+        try {
+            if (in != null)
+                in.close();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return checkPkgName(param, param_tag);
+    }
+
+    /*Function:checkTag
+     *Description:
+     * add tag name to hash map
+     *Parameter:
+     * tag - tag name in xml
+     * text - text for the tag
+     *Return:
+     * true
+     */
+    boolean addTag(String tag, String text) {
+        String pkgName = text;
+        Log.d(TAG, " pkgName = " + pkgName);
+        if (!mMap.containsKey(pkgName))
+            mMap.put(pkgName,tag);
+        return true;
+    }
+
+    boolean checkPkgName(String pkgName, String tag) {
+        String value = mMap.get(pkgName);
+        if (value == null)
+            return false;
+        else
+            return value.equals(tag);
+    }
+
+}
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 04215c5..d10c496 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -255,6 +255,13 @@ ifeq ($(WITH_MALLOC_LEAK_CHECK),true)
 	LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK
 endif
 
+ifeq ($(INTEL_HOUDINI), true)
+    LOCAL_CFLAGS += -DWITH_HOUDINI
+	LOCAL_SHARED_LIBRARIES += libdvm
+    LOCAL_STATIC_LIBRARIES += libhoudini_hook
+    LOCAL_SRC_FILES += com_android_internal_os_ZygoteConnection.cpp
+endif
+
 LOCAL_MODULE:= libandroid_runtime
 
 include external/stlport/libstlport.mk
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index b8acead..35ba9d4 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -156,6 +156,9 @@ extern int register_android_server_NetworkManagementSocketTagger(JNIEnv* env);
 extern int register_android_server_Watchdog(JNIEnv* env);
 extern int register_android_ddm_DdmHandleNativeHeap(JNIEnv *env);
 extern int register_com_android_internal_os_ZygoteInit(JNIEnv* env);
+#ifdef WITH_HOUDINI
+extern int register_com_android_internal_os_ZygoteConnection(JNIEnv* env);
+#endif
 extern int register_android_backup_BackupDataInput(JNIEnv *env);
 extern int register_android_backup_BackupDataOutput(JNIEnv *env);
 extern int register_android_backup_FileBackupHelperBase(JNIEnv *env);
@@ -1184,6 +1187,9 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_net_wifi_WifiNative),
     REG_JNI(register_android_os_MemoryFile),
     REG_JNI(register_com_android_internal_os_ZygoteInit),
+#ifdef WITH_HOUDINI
+    REG_JNI(register_com_android_internal_os_ZygoteConnection),
+#endif
     REG_JNI(register_android_hardware_Camera),
     REG_JNI(register_android_hardware_camera2_CameraMetadata),
     REG_JNI(register_android_hardware_SensorManager),
diff --git a/core/jni/android_app_NativeActivity.cpp b/core/jni/android_app_NativeActivity.cpp
index 5418006..e7860fe 100644
--- a/core/jni/android_app_NativeActivity.cpp
+++ b/core/jni/android_app_NativeActivity.cpp
@@ -41,6 +41,14 @@
 #define LOG_TRACE(...)
 //#define LOG_TRACE(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)
 
+#ifdef WITH_HOUDINI
+namespace houdini {
+void* hookDlopen(const char* filename, int flag, bool* useHoudini);
+void* hookDlsym(bool useHoudini, void* handle, const char* symbol);
+void  hookCreateActivity(bool useHoudini, void* createActivityFunc, void* activity, void*houdiniActivity, void* savedState, size_t savedStateSize);
+}
+#endif
+
 namespace android
 {
 
@@ -109,6 +117,9 @@ struct NativeCode : public ANativeActivity {
         createActivityFunc = _createFunc;
         nativeWindow = NULL;
         mainWorkRead = mainWorkWrite = -1;
+#ifdef WITH_HOUDINI
+        houdiniNativeActivity = NULL;
+#endif
     }
     
     ~NativeCode() {
@@ -130,6 +141,10 @@ struct NativeCode : public ANativeActivity {
             // is really no benefit to unloading the code.
             //dlclose(dlhandle);
         }
+#ifdef WITH_HOUDINI
+        if (houdiniNativeActivity != NULL)
+            delete houdiniNativeActivity;
+#endif
     }
     
     void setSurface(jobject _surface) {
@@ -157,6 +172,9 @@ struct NativeCode : public ANativeActivity {
     int mainWorkRead;
     int mainWorkWrite;
     sp<MessageQueue> messageQueue;
+#ifdef WITH_HOUDINI
+    ANativeActivity *houdiniNativeActivity;
+#endif
 };
 
 void android_NativeActivity_finish(ANativeActivity* activity) {
@@ -251,15 +269,25 @@ loadNativeCode_native(JNIEnv* env, jobject clazz, jstring path, jstring funcName
 
     const char* pathStr = env->GetStringUTFChars(path, NULL);
     NativeCode* code = NULL;
-    
+
+#ifdef WITH_HOUDINI
+    bool useHoudini = false;
+    void* handle = houdini::hookDlopen(pathStr, RTLD_LAZY, &useHoudini);
+#else    
     void* handle = dlopen(pathStr, RTLD_LAZY);
+#endif
     
     env->ReleaseStringUTFChars(path, pathStr);
     
     if (handle != NULL) {
         const char* funcStr = env->GetStringUTFChars(funcName, NULL);
+#ifdef WITH_HOUDINI
+        code = new NativeCode(handle, (ANativeActivity_createFunc*)
+                houdini::hookDlsym(useHoudini, handle, funcStr));
+#else
         code = new NativeCode(handle, (ANativeActivity_createFunc*)
                 dlsym(handle, funcStr));
+#endif
         env->ReleaseStringUTFChars(funcName, funcStr);
         
         if (code->createActivityFunc == NULL) {
@@ -331,7 +359,22 @@ loadNativeCode_native(JNIEnv* env, jobject clazz, jstring path, jstring funcName
             rawSavedSize = env->GetArrayLength(savedState);
         }
 
+#ifdef WITH_HOUDINI
+        if (useHoudini) {
+            /*
+             * If houdini is used, code is used by x86 code. So we create
+             * a houdini version for code. x86 version will store peer's
+             * pointer in houdiniNativeActivity each other.
+             */
+            code->houdiniNativeActivity = new ANativeActivity;
+            *code->houdiniNativeActivity = *(ANativeActivity *)code;
+        }
+
+        houdini::hookCreateActivity(useHoudini, (void*)code->createActivityFunc, (void*)code,
+                (void*)code->houdiniNativeActivity, (void*)rawSavedState, rawSavedSize);
+#else
         code->createActivityFunc(code, rawSavedState, rawSavedSize);
+#endif
 
         if (rawSavedState != NULL) {
             env->ReleaseByteArrayElements(savedState, rawSavedState, 0);
diff --git a/core/jni/com_android_internal_content_NativeLibraryHelper.cpp b/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
index 3507a9f..20a8b23 100644
--- a/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
+++ b/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
@@ -32,7 +32,8 @@
 #include <unistd.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-
+#include <vector>
+#include <string>
 
 #define APK_LIB "lib/"
 #define APK_LIB_LEN (sizeof(APK_LIB) - 1)
@@ -40,6 +41,9 @@
 #define LIB_PREFIX "/lib"
 #define LIB_PREFIX_LEN (sizeof(LIB_PREFIX) - 1)
 
+#define APK_ASSETS "assets/"
+#define APK_ASSETS_LEN (sizeof(APK_ASSETS) - 1)
+
 #define LIB_SUFFIX ".so"
 #define LIB_SUFFIX_LEN (sizeof(LIB_SUFFIX) - 1)
 
@@ -54,8 +58,20 @@ namespace android {
 // These match PackageManager.java install codes
 typedef enum {
     INSTALL_SUCCEEDED = 1,
+#ifdef WITH_HOUDINI
+    INSTALL_ABI2_SUCCEEDED = 2,
+    INSTALL_ABI_SUCCEEDED = 99,
+    INSTALL_MISMATCH_ABI2_SUCCEEDED = 100,
+    INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED = 101,
+    INSTALL_UPGRADEABI_SUCCEEDED = 102,
+    INSTALL_IMPLICIT_ABI2_SUCCEEDED = 103,
+    INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED = 104,
+#endif
     INSTALL_FAILED_INVALID_APK = -2,
     INSTALL_FAILED_INSUFFICIENT_STORAGE = -4,
+#ifdef WITH_HOUDINI
+    INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -16,
+#endif
     INSTALL_FAILED_CONTAINER_ERROR = -18,
     INSTALL_FAILED_INTERNAL_ERROR = -110,
 } install_status_t;
@@ -157,6 +173,14 @@ sumFiles(JNIEnv* env, void* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, const
     return INSTALL_SUCCEEDED;
 }
 
+#ifdef WITH_HOUDINI
+static install_status_t
+listFiles(JNIEnv* env, void* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, const char* fileName)
+{
+    return INSTALL_SUCCEEDED;
+}
+#endif
+
 /*
  * Copy the native library if needed.
  *
@@ -284,6 +308,10 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
 
     char fileName[PATH_MAX];
     bool hasPrimaryAbi = false;
+#ifdef WITH_HOUDINI
+    bool useSecondaryAbi = false;
+    bool noMatchAbi = false;
+#endif
 
     for (int i = 0; i < N; i++) {
         const ZipEntryRO entry = zipFile.findEntryByIndex(i);
@@ -333,9 +361,15 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
                 ALOGV("Already saw primary ABI, skipping secondary ABI %s\n", cpuAbi2.c_str());
                 continue;
             } else {
+#ifdef WITH_HOUDINI
+                useSecondaryAbi = true;
+#endif
                 ALOGV("Using secondary ABI %s\n", cpuAbi2.c_str());
             }
         } else {
+#ifdef WITH_HOUDINI
+            noMatchAbi = true;
+#endif
             ALOGV("abi didn't match anything: %s (end at %zd)\n", cpuAbiOffset, cpuAbiRegionSize);
             continue;
         }
@@ -355,6 +389,11 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
         }
     }
 
+#ifdef WITH_HOUDINI
+    if (!hasPrimaryAbi && useSecondaryAbi)
+        return INSTALL_ABI2_SUCCEEDED;
+#endif
+
     return INSTALL_SUCCEEDED;
 }
 
@@ -377,6 +416,301 @@ com_android_internal_content_NativeLibraryHelper_sumNativeBinaries(JNIEnv *env,
     return totalSize;
 }
 
+#ifdef WITH_HOUDINI
+
+#define MAX_LIB_NAME_LEN    128
+#define ASSETS_LIB_LIST_FILE    "/system/lib/arm/.assets_lib_list"
+
+static std::vector<std::string> lib_list;
+static bool lib_list_inited = false;
+
+static void init_lib_list()
+{
+    char line[MAX_LIB_NAME_LEN];
+    int i = 0;
+
+    FILE* fp = fopen(ASSETS_LIB_LIST_FILE, "r");
+    if (NULL == fp) {
+        ALOGE("Couldn't open file %s: %s", ASSETS_LIB_LIST_FILE, strerror(errno));
+        return;
+    }
+
+    while (fgets(line, MAX_LIB_NAME_LEN, fp)) {
+        if ('#' == line[0])
+            continue;
+        line[strlen(line) - 1] = '\0';
+        lib_list.push_back(line);
+    }
+
+    // ALOGD("assets_lib_list:");
+    // for (i = 0; i < lib_list.size(); ++i) {
+    //     ALOGD("%s\n", lib_list[i].c_str());
+    // }
+
+    fclose(fp);
+    return;
+}
+
+static const char* intel_arch[] = {
+    "intel",
+    "Intel",
+    "INTEL",
+    "x86",
+    "X86",
+    NULL
+};
+
+static const char * sep_char = "-_.";
+
+static size_t passArchStr (std::string str)
+{
+    int j = 0;
+    size_t pos = ~0;
+
+    for (j=0; intel_arch[j] != NULL; j++) {
+        size_t i = str.find(intel_arch[j]);
+
+        if (i != std::string::npos && i < pos) {
+            // pass seperate char
+            while (i>0 && strchr(sep_char, str[i-1]))
+                i--;
+            pos = i;
+        }
+    }
+
+    return pos;
+}
+
+
+static bool checkLibName(std::vector<std::string> stdAbi, std::vector<std::string> primAbi)
+{
+    if (0 == primAbi.size()
+            || 0 == stdAbi.size())
+        return false;
+
+    for (size_t i=0; i<primAbi.size(); i++) {
+        size_t m = ~0;
+        std::string primStr(primAbi[i]);
+
+        m = passArchStr(primStr);
+        // Not find arch string
+        if (~0 == m || 0 == m)
+            return false;
+
+        std::string primSubStr = primStr.substr(0, m);
+
+        size_t j = 0;
+        for (j=0; j<stdAbi.size(); j++) {
+            size_t n = ~0;
+            std::string stdStr(stdAbi[j]);
+
+            n = stdStr.find(primSubStr);
+            if (0 == n)
+                break;
+        }
+
+        // Find one mismatch lib
+        if (j >= stdAbi.size())
+            return false;
+    }
+
+    return true;
+}
+
+
+/*
+ * Scan apk to figure out which abi libs should be used on intel platform
+ * Return values:
+ *  INSTALL_MISMATCH_ABI2_SUCCEEDED - lib mismatch and should use abi2 libs
+ *  INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED - lib mismatch and should use upgradeabi libs
+ *  INSTALL_ABI_SUCCEEDED - should install abi lib
+ *  INSTALL_ABI2_SUCCEEDED - should install abi2 libs
+ *  INSTALL_UPGRADEABI_SUCCEEDED - should install upgrade abi libs
+ *  INSTALL_SUCCEEDED - install java app
+ *
+ */
+static jint
+com_android_internal_content_NativeLibraryHelper_listNativeBinaries(JNIEnv *env, jclass clazz,
+        jstring javaFilePath, jstring javaCpuAbi, jstring javaCpuAbi2,jstring javaUpgradeAbi)
+{
+
+    ScopedUtfChars filePath(env, javaFilePath);
+    ScopedUtfChars cpuAbi(env, javaCpuAbi);
+    ScopedUtfChars cpuAbi2(env, javaCpuAbi2);
+    ScopedUtfChars upgradeAbi(env, javaUpgradeAbi);
+
+    std::vector<std::string> cpuAbi_lib;
+    std::vector<std::string> cpuAbi2_lib;
+    std::vector<std::string> upgradeAbi_lib;
+
+    ZipFileRO zipFile;
+
+    if (filePath.c_str() == NULL) {
+        ALOGE("APK file patch is NULLI\n");
+        return INSTALL_FAILED_INVALID_APK;
+    }
+
+    if (zipFile.open(filePath.c_str()) != NO_ERROR) {
+        ALOGI("Couldn't open APK %s\n", filePath.c_str());
+        return INSTALL_FAILED_INVALID_APK;
+    }
+
+    const int N = zipFile.getNumEntries();
+
+    char fileName[PATH_MAX];
+    bool hasPrimaryAbi = false;
+    bool hasSecondaryAbi = false;
+    bool hasUpgradeAbi = false;
+    bool hasX86Assert = false;
+    bool noMatchAbi = false;
+    int priAbiLib = 0;
+    int secAbiLib = 0;
+    int upgradeAbiLib = 0;
+
+    for (int i = 0; i < N; i++) {
+        const ZipEntryRO entry = zipFile.findEntryByIndex(i);
+        if (entry == NULL) {
+            continue;
+        }
+
+        // Make sure this entry has a filename.
+        if (zipFile.getEntryFileName(entry, fileName, sizeof(fileName))) {
+            continue;
+        }
+
+        // Make sure we're in the assets directory of the ZIP.
+        if (!strncmp(fileName, APK_ASSETS, APK_ASSETS_LEN)) {
+            // Make sure the filename is at least to the minimum library name size.
+            const size_t fileNameLen = strlen(fileName);
+            static const size_t minLength = APK_ASSETS_LEN + 2 + LIB_PREFIX_LEN + 1 + LIB_SUFFIX_LEN;
+            if (fileNameLen < minLength) {
+                continue;
+            }
+
+            const char* lastSlash = strrchr(fileName, '/');
+            ALOG_ASSERT(lastSlash != NULL, "last slash was null somehow for %s\n", fileName);
+            if (lastSlash == NULL) {
+                ALOGE("last slash was null\n");
+                continue;
+            }
+
+            // Make sure it's in the root of assets folder.
+            if ((lastSlash - fileName) != (APK_ASSETS_LEN - 1))
+                continue;
+
+            if (strncmp(fileName + fileNameLen - LIB_SUFFIX_LEN, LIB_SUFFIX, LIB_SUFFIX_LEN)
+                    || strncmp(lastSlash, LIB_PREFIX, LIB_PREFIX_LEN)
+                    || !isFilenameSafe(lastSlash + 1))
+                continue;
+
+            if (false == lib_list_inited) {
+                init_lib_list();
+                lib_list_inited = true;
+            }
+
+            for (size_t j = 0; j < lib_list.size(); ++j) {
+                if (!strncmp(lastSlash + LIB_PREFIX_LEN, lib_list[j].c_str(), lib_list[j].length())) {
+                    //find x86 assert lib
+                    hasX86Assert = true;
+                    continue;
+                }
+            }
+        }
+
+        // Make sure we're in the lib directory of the ZIP.
+        if (strncmp(fileName, APK_LIB, APK_LIB_LEN)) {
+            continue;
+        }
+
+        // Make sure the filename is at least to the minimum library name size.
+        const size_t fileNameLen = strlen(fileName);
+        static const size_t minLength = APK_LIB_LEN + 2 + LIB_PREFIX_LEN + 1 + LIB_SUFFIX_LEN;
+        if (fileNameLen < minLength) {
+            continue;
+        }
+
+        const char* lastSlash = strrchr(fileName, '/');
+        ALOG_ASSERT(lastSlash != NULL, "last slash was null somehow for %s\n", fileName);
+
+        // Check to make sure the CPU ABI of this file is one we support.
+        const char* cpuAbiOffset = fileName + APK_LIB_LEN;
+        const size_t cpuAbiRegionSize = lastSlash - cpuAbiOffset;
+        const char* libName = lastSlash + 1;
+
+        ALOGV("Comparing ABIs %s and %s versus %s\n", cpuAbi.c_str(), cpuAbi2.c_str(), cpuAbiOffset);
+        if (cpuAbi.size() == cpuAbiRegionSize
+                && *(cpuAbiOffset + cpuAbi.size()) == '/'
+                && !strncmp(cpuAbiOffset, cpuAbi.c_str(), cpuAbiRegionSize)) {
+            ALOGV("Finding primary ABI %s\n", cpuAbi.c_str());
+            hasPrimaryAbi = true;
+            priAbiLib++;
+            for (int j=0; intel_arch[j] != NULL; j++) {
+                if ((libName != NULL) && (strstr(libName, intel_arch[j]) != NULL)) {
+                    cpuAbi_lib.push_back(libName);
+                    break;
+                }
+            }
+        } else if (cpuAbi2.size() == cpuAbiRegionSize
+                && *(cpuAbiOffset + cpuAbi2.size()) == '/'
+                && !strncmp(cpuAbiOffset, cpuAbi2.c_str(), cpuAbiRegionSize)) {
+                    ALOGV("Finding secondary ABI %s\n", cpuAbi2.c_str());
+                    hasSecondaryAbi = true;
+                    secAbiLib++;
+                    cpuAbi2_lib.push_back(libName);
+        } else if (upgradeAbi.size() == cpuAbiRegionSize
+                && *(cpuAbiOffset + upgradeAbi.size()) == '/'
+                && !strncmp(cpuAbiOffset, upgradeAbi.c_str(), cpuAbiRegionSize)) {
+                    ALOGV("Finding upgrade ABI %s\n", upgradeAbi.c_str());
+                    hasUpgradeAbi = true;
+                    upgradeAbiLib++;
+                    upgradeAbi_lib.push_back(libName);
+        } else {
+                ALOGV("abi didn't match anything: %s (end at %zd)\n", cpuAbiOffset, cpuAbiRegionSize);
+                noMatchAbi = true;
+        }
+    }
+
+    if ((hasPrimaryAbi == false && hasSecondaryAbi == true && hasX86Assert == true)) {
+        return INSTALL_IMPLICIT_ABI2_SUCCEEDED;
+    }
+
+    if ((hasPrimaryAbi == false && hasUpgradeAbi == true && hasX86Assert == true)) {
+        return INSTALL_IMPLICIT_UPGRADEABI_SUCCEEDED;
+    }
+
+    if (hasPrimaryAbi == true && hasSecondaryAbi == true && priAbiLib != secAbiLib) {
+        if (checkLibName(cpuAbi2_lib, cpuAbi_lib)) {
+            return INSTALL_SUCCEEDED;
+        }
+        return INSTALL_MISMATCH_ABI2_SUCCEEDED;
+    }
+
+    if (hasPrimaryAbi == true && hasSecondaryAbi == false && hasUpgradeAbi == true && priAbiLib != upgradeAbiLib) {
+        if (checkLibName(upgradeAbi_lib, cpuAbi_lib)) {
+            return INSTALL_SUCCEEDED;
+        }
+        return INSTALL_MISMATCH_UPGRADEABI_SUCCEEDED;
+    }
+
+    if ((hasPrimaryAbi == true && hasSecondaryAbi == true && priAbiLib == secAbiLib) ||
+            (hasPrimaryAbi == true && hasSecondaryAbi == false && hasUpgradeAbi == true &&
+                    priAbiLib == upgradeAbiLib) || (hasPrimaryAbi == true &&
+                            hasSecondaryAbi == false && hasUpgradeAbi == false)) {
+        return INSTALL_ABI_SUCCEEDED;
+    }
+
+    if (hasPrimaryAbi == false && hasSecondaryAbi == false && hasUpgradeAbi == true) {
+        return INSTALL_UPGRADEABI_SUCCEEDED;
+    }
+
+    if (hasPrimaryAbi == false && hasSecondaryAbi == true) {
+        return INSTALL_ABI2_SUCCEEDED;
+    }
+
+    return INSTALL_SUCCEEDED;
+}
+#endif
+
 static JNINativeMethod gMethods[] = {
     {"nativeCopyNativeBinaries",
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
@@ -384,6 +718,11 @@ static JNINativeMethod gMethods[] = {
     {"nativeSumNativeBinaries",
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)J",
             (void *)com_android_internal_content_NativeLibraryHelper_sumNativeBinaries},
+#ifdef WITH_HOUDINI
+    {"nativeListNativeBinaries",
+            "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
+            (void *)com_android_internal_content_NativeLibraryHelper_listNativeBinaries},
+#endif
 };
 
 
diff --git a/core/jni/com_android_internal_os_ZygoteConnection.cpp b/core/jni/com_android_internal_os_ZygoteConnection.cpp
new file mode 100644
index 0000000..e3400bc
--- /dev/null
+++ b/core/jni/com_android_internal_os_ZygoteConnection.cpp
@@ -0,0 +1,113 @@
+#define LOG_TAG "Zygote"
+
+#include "jni.h"
+#include <JNIHelp.h>
+#include "android_runtime/AndroidRuntime.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include "cutils/properties.h"
+
+namespace android {
+
+// re-define Field and StaticField struct here
+struct F {
+    void *clz;
+    char *name;
+    char *sig;
+    int flags;
+};
+
+struct sF : F {
+    void *p;
+};
+
+static void com_android_internal_os_ZygoteConnection_settingHoudiniABI (JNIEnv *env, jobject clazz)
+{
+    jclass c = env->FindClass("android/os/Build");
+    jfieldID f1 = env->GetStaticFieldID(c, "CPU_ABI", "Ljava/lang/String;");
+    jfieldID f2 = env->GetStaticFieldID(c, "CPU_ABI2", "Ljava/lang/String;");
+    jfieldID f3 = env->GetStaticFieldID(c, "HOUDINI_ABI", "Ljava/lang/String;");
+    jfieldID f4 = env->GetStaticFieldID(c, "HOUDINI_ABI2", "Ljava/lang/String;");
+
+    struct sF* abi = (struct sF*)f1;
+    struct sF* abi2 = (struct sF*)f2;
+    struct sF* houdini_abi = (struct sF*)f3;
+    struct sF* houdini_abi2 = (struct sF*)f4;
+    abi->p = houdini_abi->p;
+    abi2->p = houdini_abi2->p;
+
+    return;
+}
+
+#define APP_WITH_ABI2               "/data/data/.appwithABI2"
+#define APP_WITH_IMPLICIT_ABI       "/data/.appwithImplicitABI"
+#define APP_ABI2_FLAG               1
+#define APP_IMPLICIT_ABI_FLAG       2
+
+static jint com_android_internal_os_ZygoteConnection_isABI2App (JNIEnv *env, jobject clazz, jint appId)
+{
+    int app_abi_flag = 0;
+    int fd = open(APP_WITH_ABI2, O_RDONLY,0444);
+    if (fd != -1) {
+        int pkgAppId = 0;
+        while (read(fd, &pkgAppId, 4) > 0) {
+            if (appId == pkgAppId) {
+                app_abi_flag |= APP_ABI2_FLAG;
+                break;
+            }
+        }
+        close(fd);
+    }
+
+    if (!(app_abi_flag & APP_ABI2_FLAG))
+        return (jint)app_abi_flag;
+
+    fd = open(APP_WITH_IMPLICIT_ABI, O_RDONLY,0444);
+    if (fd != -1) {
+        int pkgAppId = 0;
+        while (read(fd, &pkgAppId, 4) > 0) {
+            if (appId == pkgAppId) {
+                app_abi_flag |= APP_IMPLICIT_ABI_FLAG;
+                break;
+            }
+        }
+        close(fd);
+    }
+
+    return (jint)app_abi_flag;
+}
+
+#ifdef WITH_HOUDINI
+extern void *houdini_handler;
+
+static void com_android_internal_os_ZygoteConnection_unloadHoudini ()
+{
+    if (houdini_handler)
+        dlclose(houdini_handler);
+}
+#endif
+
+/*
+ * JNI registration.
+ */
+static JNINativeMethod gMethods[] = {
+    /* name, signature, funcPtr */
+    { "settingHoudiniABI", "()V",
+        (void *) com_android_internal_os_ZygoteConnection_settingHoudiniABI },
+    { "isABI2App", "(I)I",
+        (void *) com_android_internal_os_ZygoteConnection_isABI2App },
+#ifdef WITH_HOUDINI
+    { "unloadHoudini", "()V",
+        (void *) com_android_internal_os_ZygoteConnection_unloadHoudini },
+#endif
+};
+
+int register_com_android_internal_os_ZygoteConnection(JNIEnv* env)
+{
+    return AndroidRuntime::registerNativeMethods(env,
+            "com/android/internal/os/ZygoteConnection", gMethods, NELEM(gMethods));
+}
+
+}; // namespace android
diff --git a/core/jni/com_android_internal_os_ZygoteInit.cpp b/core/jni/com_android_internal_os_ZygoteInit.cpp
index 44452f0..0466876 100644
--- a/core/jni/com_android_internal_os_ZygoteInit.cpp
+++ b/core/jni/com_android_internal_os_ZygoteInit.cpp
@@ -22,6 +22,7 @@
 #include <utils/misc.h>
 #include <errno.h>
 #include <sys/select.h>
+#include <dlfcn.h>
 
 #include "jni.h"
 #include <JNIHelp.h>
@@ -255,6 +256,15 @@ static jobject com_android_internal_os_ZygoteInit_createFileDescriptor (
     return jniCreateFileDescriptor(env, fd);
 }
 
+#ifdef WITH_HOUDINI
+void *houdini_handler = NULL;
+static void com_android_internal_os_ZygoteInit_preloadHoudini ()
+{
+    if (houdini_handler == NULL)
+        houdini_handler = dlopen("/system/lib/libhoudini.so", RTLD_LAZY);
+}
+#endif
+
 /*
  * JNI registration.
  */
@@ -279,8 +289,13 @@ static JNINativeMethod gMethods[] = {
     { "selectReadable", "([Ljava/io/FileDescriptor;)I",
         (void *) com_android_internal_os_ZygoteInit_selectReadable },
     { "createFileDescriptor", "(I)Ljava/io/FileDescriptor;",
-        (void *) com_android_internal_os_ZygoteInit_createFileDescriptor }
+        (void *) com_android_internal_os_ZygoteInit_createFileDescriptor },
+#ifdef WITH_HOUDINI
+    { "preloadHoudini", "()V",
+        (void *) com_android_internal_os_ZygoteInit_preloadHoudini }
+#endif
 };
+
 int register_com_android_internal_os_ZygoteInit(JNIEnv* env)
 {
     return AndroidRuntime::registerNativeMethods(env,
diff --git a/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java b/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
index 13e1030..0ab7594 100644
--- a/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
+++ b/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
@@ -30,6 +30,7 @@ import android.content.pm.PackageParser;
 import android.content.res.ObbInfo;
 import android.content.res.ObbScanner;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Environment;
 import android.os.Environment.UserEnvironment;
 import android.os.FileUtils;
@@ -41,6 +42,7 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.StatFs;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.provider.Settings;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -458,10 +460,20 @@ public class DefaultContainerService extends IntentService {
         final File sharedLibraryDir = new File(newCachePath, LIB_DIR_NAME);
         if (sharedLibraryDir.mkdir()) {
             int ret = NativeLibraryHelper.copyNativeBinariesIfNeededLI(codeFile, sharedLibraryDir);
-            if (ret != PackageManager.INSTALL_SUCCEEDED) {
-                Slog.e(TAG, "Could not copy native libraries to " + sharedLibraryDir.getPath());
-                PackageHelper.destroySdDir(newCid);
-                return null;
+            String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+            if (abi2.length() != 0) {
+                if ((ret != PackageManager.INSTALL_SUCCEEDED) &&
+                        (ret != PackageManager.INSTALL_ABI2_SUCCEEDED)) {
+                    Slog.e(TAG, "Could not copy native libraries to " + sharedLibraryDir.getPath());
+                    PackageHelper.destroySdDir(newCid);
+                    return null;
+                }
+            } else {
+                if (ret != PackageManager.INSTALL_SUCCEEDED) {
+                    Slog.e(TAG, "Could not copy native libraries to " + sharedLibraryDir.getPath());
+                    PackageHelper.destroySdDir(newCid);
+                    return null;
+                }
             }
         } else {
             Slog.e(TAG, "Could not create native lib directory: " + sharedLibraryDir.getPath());
diff --git a/services/java/com/android/server/pm/PackageManagerService.java b/services/java/com/android/server/pm/PackageManagerService.java
old mode 100644
new mode 100755
index 07b8d99..4ff4a05
--- a/services/java/com/android/server/pm/PackageManagerService.java
+++ b/services/java/com/android/server/pm/PackageManagerService.java
@@ -42,6 +42,8 @@ import com.android.internal.app.IMediaContainerService;
 import com.android.internal.app.ResolverActivity;
 import com.android.internal.content.NativeLibraryHelper;
 import com.android.internal.content.PackageHelper;
+import com.android.internal.os.CheckExt;
+import com.android.internal.os.ICheckExt;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.FastXmlSerializer;
 import com.android.internal.util.XmlUtils;
@@ -157,6 +159,7 @@ import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.FilenameFilter;
 import java.io.IOException;
+import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -596,6 +599,13 @@ public class PackageManagerService extends IPackageManager.Stub {
     // or internal storage.
     private IMediaContainerService mContainerService = null;
 
+    // Packages that have been installed with library matching 2nd ABI.
+    final HashMap<Integer, String> mPackagesMatchABI2 = new HashMap<Integer, String>();
+    // Packages that have been installed with x86 lib in the assets folder.
+    final HashMap<Integer, String> mPackagesImplicitABI = new HashMap<Integer, String>();
+    // Packages that have been installed with library matching 2nd ABI and matching neon app list
+    final HashMap<Integer, String> mPackagesMatchABI2Neon = new HashMap<Integer, String>();
+
     static final int SEND_PENDING_BROADCAST = 1;
     static final int MCS_BOUND = 3;
     static final int END_COPY = 4;
@@ -4362,6 +4372,59 @@ public class PackageManagerService extends IPackageManager.Stub {
         return new File(mUserAppDataDir.getAbsolutePath() + File.separator + userId);
     }
 
+    private void writeAppwithABI2Internal(String fileName, HashMap<Integer, String> map) {
+        File outputFile;
+        FileOutputStream out = null;
+        File appDataDir = new File("/data/data");
+
+        try {
+            File tempFile = File.createTempFile("tmp", "tmp", appDataDir);
+            String tempFilePath = tempFile.getPath();
+            outputFile = new File(fileName);
+            if (FileUtils.setPermissions(tempFilePath,
+                    FileUtils.S_IRUSR | FileUtils.S_IWUSR |
+                    FileUtils.S_IRGRP | FileUtils.S_IROTH, -1, -1) != 0
+                    || !tempFile.renameTo(outputFile)) {
+                tempFile.delete();
+            }
+            out = new FileOutputStream(outputFile);
+            Iterator<HashMap.Entry<Integer, String>>
+            it = map.entrySet().iterator();
+            while (it.hasNext()) {
+                HashMap.Entry<Integer, String> ent = it.next();
+                int userID = ent.getKey().intValue();
+                out.write(userID & 0xff);
+                out.write((userID>>8)  & 0xff);
+                out.write((userID>>16) & 0xff);
+                out.write((userID>>24) & 0xff);
+                Slog.i(TAG, "Data written:"+ userID);
+            }
+        } catch (Exception e) {
+            Slog.e(TAG, "File Access Error: Not Able to write Data into " + fileName);
+        } finally {
+            try {
+                if (out != null) {
+                    out.close();
+                    Slog.i(TAG, "Data written into " + fileName);
+                }
+            } catch (IOException e) {}
+        }
+    }
+
+    private void writeAppwithABI2() {
+        writeAppwithABI2Internal(new String("/data/data/.appwithABI2"), mPackagesMatchABI2);
+        writeAppwithABI2Internal(new String("/data/.appwithImplicitABI"), mPackagesImplicitABI);
+    }
+
+    private void writeAppwithABI2Neon() {
+        writeAppwithABI2Internal(new String("/data/data/.appwithABI2neon"), mPackagesMatchABI2Neon);
+    }
+
+    private void rmUidFromABI2List(int uid) {
+        mPackagesMatchABI2.remove(uid);
+        mPackagesImplicitABI.remove(uid);
+    }
+
     private File getDataPathForPackage(String packageName, int userId) {
         /*
          * Until we fully support multiple users, return the directory we
@@ -4710,6 +4773,27 @@ public class PackageManagerService extends IPackageManager.Stub {
                 Slog.w(TAG, "Package " + pkg.packageName
                         + " was transferred to another, but its .apk remains");
             }
+
+            String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+            if (abi2.length() != 0) {
+                PackageSetting p = mSettings.mPackages.get(pkg.packageName);
+                if ((p != null) && (!p.codePath.equals(destCodeFile))) {
+
+                    // Already existing package. Make sure not upgrade to black list
+                    int result = NativeLibraryHelper.listNativeBinariesLI(scanFile,
+                            pkg.packageName);
+
+                    if (result == PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                        ICheckExt check = new CheckExt();
+                        if(check.doCheck(pkg.packageName, new String("filter"))) {
+                            Slog.i(TAG, "Reject application in black list::" + pkg.packageName);
+                            mLastScanError = PackageManager.INSTALL_FAILED_INVALID_APK;
+                            return null;
+                        }
+                    }
+
+                }
+            }
             
             // Just create the setting, don't add it yet. For already existing packages
             // the PkgSetting exists already and doesn't have to be created.
@@ -5024,10 +5108,22 @@ public class PackageManagerService extends IPackageManager.Stub {
                         }
 
                         try {
-                            if (copyNativeLibrariesForInternalApp(scanFile, nativeLibraryDir) != PackageManager.INSTALL_SUCCEEDED) {
-                                Slog.e(TAG, "Unable to copy native libraries");
-                                mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
-                                return null;
+                            int copyRet = copyNativeLibrariesForInternalApp(scanFile,
+                                    nativeLibraryDir);
+                            String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+                            if (abi2.length() != 0) {
+                                if (copyRet != PackageManager.INSTALL_SUCCEEDED
+                                        && copyRet != PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                                    Slog.e(TAG, "Unable to copy native libraries");
+                                    mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
+                                    return null;
+                                }
+                            } else {
+                                if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
+                                    Slog.e(TAG, "Unable to copy native libraries");
+                                    mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
+                                    return null;
+                                }
                             }
                         } catch (IOException e) {
                             Slog.e(TAG, "Unable to copy native libraries", e);
@@ -5036,6 +5132,7 @@ public class PackageManagerService extends IPackageManager.Stub {
                         }
                     }
 
+
                     if (DEBUG_INSTALL) Slog.i(TAG, "Linking native library dir for " + path);
                     final int[] userIds = sUserManager.getUserIds();
                     synchronized (mInstallLock) {
@@ -5050,6 +5147,51 @@ public class PackageManagerService extends IPackageManager.Stub {
                         }
                     }
                 }
+
+                // Check the apk to see whether it contains ABI2 library.
+                int result = NativeLibraryHelper.listNativeBinariesLI(scanFile, pkg.packageName);
+                String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+                if (result == PackageManager.INSTALL_SUCCEEDED) {
+                    if ((abi2.length() != 0) && mPackagesMatchABI2.containsKey(pkg.applicationInfo.uid)) {
+                        Slog.i(TAG, "Replace package with primary ABI Library");
+                        rmUidFromABI2List(pkg.applicationInfo.uid);
+                        writeAppwithABI2();
+                        if (mPackagesMatchABI2Neon.containsKey(pkg.applicationInfo.uid)) {
+                            mPackagesMatchABI2Neon.remove(pkg.applicationInfo.uid);
+                            writeAppwithABI2Neon();
+                        }
+                    }
+                } else if ((abi2.length() != 0) && (result == PackageManager.INSTALL_ABI2_SUCCEEDED
+                        || result == PackageManager.INSTALL_IMPLICIT_ABI_SUCCEEDED)
+                        && !mPackagesMatchABI2.containsKey(pkg.applicationInfo.uid)) {
+                    ICheckExt check = new CheckExt();
+                    if (check.doCheck(pkgName, new String("filter"))) {
+                        Slog.i(TAG, "Package with second ABI is in black list: "
+                                + pkg.applicationInfo.uid + pkg.applicationInfo.processName);
+                        mLastScanError = PackageManager.INSTALL_FAILED_INVALID_APK;
+                        return null;
+                    }
+                    Slog.i(TAG, "Package installed with second ABI Library: "
+                            + pkg.applicationInfo.uid + pkg.applicationInfo.processName);
+                    if (result == PackageManager.INSTALL_IMPLICIT_ABI_SUCCEEDED) {
+                        mPackagesImplicitABI.put(pkg.applicationInfo.uid,
+                                pkg.applicationInfo.processName);
+                        mPackagesMatchABI2.put(pkg.applicationInfo.uid,
+                                pkg.applicationInfo.processName);
+                    } else if (result == PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                        mPackagesMatchABI2.put(pkg.applicationInfo.uid,
+                                pkg.applicationInfo.processName);
+                    } else {
+                        Slog.e(TAG, "Shouldn't be here");
+                    }
+                    writeAppwithABI2();
+                    if (check.doCheck(pkgName, new String("neon"))) {
+                        mPackagesMatchABI2Neon.put(pkg.applicationInfo.uid,
+                                pkg.applicationInfo.processName);
+                        writeAppwithABI2Neon();
+                    }
+                }
+
             } catch (IOException ioe) {
                 Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
             }
@@ -6181,6 +6323,19 @@ public class PackageManagerService extends IPackageManager.Stub {
             final PackageParser.Package pkg = ps.pkg;
             if (pkg != null) {
                 cleanPackageDataStructuresLILPw(pkg, chatty);
+
+                Integer pkgUidInt = new Integer(pkg.applicationInfo.uid);
+                String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+                if ((abi2.length() != 0) && mPackagesMatchABI2.containsKey(pkgUidInt)) {
+                    Slog.i(TAG, "Uninstall package with second ABI Library");
+                    rmUidFromABI2List(pkg.applicationInfo.uid);
+                    writeAppwithABI2();
+                    if (mPackagesMatchABI2Neon.containsKey(pkgUidInt)) {
+                        mPackagesMatchABI2Neon.remove(pkgUidInt);
+                        writeAppwithABI2Neon();
+                    }
+                }
+
             }
         }
     }
@@ -6198,6 +6353,19 @@ public class PackageManagerService extends IPackageManager.Stub {
                 mAppDirs.remove(pkg.mPath);
             }
             cleanPackageDataStructuresLILPw(pkg, chatty);
+
+            String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+            if ((abi2.length() != 0) && mPackagesMatchABI2.containsKey(new
+                    Integer(pkg.applicationInfo.uid))) {
+                Slog.i(TAG, "Uninstall package with second ABI Library");
+                rmUidFromABI2List(pkg.applicationInfo.uid);
+                writeAppwithABI2();
+                if (mPackagesMatchABI2Neon.containsKey(new Integer(pkg.applicationInfo.uid))) {
+                    mPackagesMatchABI2Neon.remove(new Integer(pkg.applicationInfo.uid));
+                    writeAppwithABI2Neon();
+                }
+            }
+
         }
     }
 
@@ -9079,8 +9247,16 @@ public class PackageManagerService extends IPackageManager.Stub {
             }
             try {
                 int copyRet = copyNativeLibrariesForInternalApp(codeFile, nativeLibraryFile);
-                if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
-                    return copyRet;
+                String abi2 = SystemProperties.get("ro.product.cpu.abi2");
+                if (abi2.length() != 0) {
+                    if (copyRet != PackageManager.INSTALL_SUCCEEDED
+                            && copyRet != PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                        return copyRet;
+                    }
+                } else {
+                    if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
+                        return copyRet;
+                    }
                 }
             } catch (IOException e) {
                 Slog.e(TAG, "Copying native libraries failed", e);
-- 
2.7.4

