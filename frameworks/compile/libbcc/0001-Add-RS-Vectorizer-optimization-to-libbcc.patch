From 31c8a58a339f64a5b98a5f0c0101a3e891c2f11a Mon Sep 17 00:00:00 2001
From: Yong Chen <yong.a.chen@intel.com>
Date: Thu, 22 Aug 2013 18:19:02 +0800
Subject: [PATCH 1/2] Add RS Vectorizer optimization to libbcc

BZ: 133478

Turn on hueristic and update to drop7. Enable RS Vectorizer
by setting: adb shell setprop debug.rs.x86vectorizer 1

Change-Id: Id0903b90c6cf9eab1228077872cdf7ba15f71f5b
Category: feature differentiation
Domain: AOSP-RenderScript
Origin: internal
Upstream-Candidate: no, proprietary
Orig-ABT-Change-Id: Id4e5306607ef893c6952b846436369f1d28cb769
Signed-off-by: Yong Chen <yong.a.chen@intel.com>
Reviewed-on: http://android.intel.com:8080/127714
Reviewed-by: Rose, James <james.rose@intel.com>
Reviewed-by: Li, Xiao-Feng <xiao-feng.li@intel.com>
Tested-by: Shentu, JiazhenX <jiazhenx.shentu@intel.com>
Reviewed-by: cactus <cactus@intel.com>
Tested-by: cactus <cactus@intel.com>
---
 Android.mk                                        |   27 +
 include/bcc/Compiler.h                            |   10 +
 include/bcc/Renderscript/RSCompiler.h             |    7 +
 include/bcc/Renderscript/RSInfo.h                 |    2 +
 include/bcc/Renderscript/RSVectorization.h        |   25 +
 include/bcc/Renderscript/RSVectorizationSupport.h |   68 ++
 lib/Core/Compiler.cpp                             |   15 +
 lib/Renderscript/Android.mk                       |   13 +-
 lib/Renderscript/RSCompiler.cpp                   |   35 +
 lib/Renderscript/RSCompilerDriver.cpp             |   38 +
 lib/Renderscript/RSForEachExpand_x86.cpp          | 1001 ++++++++++++++++++
 lib/Renderscript/RSInfo.cpp                       |   10 +
 lib/Renderscript/RSVectorizationSupport.cpp       | 1132 +++++++++++++++++++++
 13 files changed, 2382 insertions(+), 1 deletion(-)
 create mode 100644 include/bcc/Renderscript/RSVectorization.h
 create mode 100644 include/bcc/Renderscript/RSVectorizationSupport.h
 create mode 100644 lib/Renderscript/RSForEachExpand_x86.cpp
 create mode 100644 lib/Renderscript/RSVectorizationSupport.cpp

diff --git a/Android.mk b/Android.mk
index c26a122..7b3afd4 100644
--- a/Android.mk
+++ b/Android.mk
@@ -21,6 +21,12 @@ LOCAL_PATH := $(call my-dir)
 LIBBCC_ROOT_PATH := $(LOCAL_PATH)
 include $(LIBBCC_ROOT_PATH)/libbcc.mk
 
+ifeq ($(TARGET_ARCH),x86)
+	include $(CLEAR_VARS)
+	LOCAL_PREBUILT_LIBS :=  ../../../prebuilts/ndk/8/sources/cxx-stl/gnu-libstdc++/libs/x86/libsupc++.a
+	LOCAL_MODULE_TAGS := optional
+	include $(BUILD_MULTI_PREBUILT)
+endif
 #=====================================================================
 # Whole Static Library to Be Linked In
 #=====================================================================
@@ -31,6 +37,15 @@ libbcc_WHOLE_STATIC_LIBRARIES += \
   libbccCore \
   libbccSupport
 
+rs_vectorizer_STATIC_LIBRARIES := \
+  libpasses \
+  libmetadata_api \
+  libname_mangle \
+  libreflection_module \
+  libLLVMVectorizer
+
+rs_vectorizer_STATIC_LIBRARIES_HOST  := $(addsuffix _host, $(notdir $(rs_vectorizer_STATIC_LIBRARIES)))
+
 #=====================================================================
 # Calculate SHA1 checksum for libbcc.so, libRS.so and libclcore.bc
 #=====================================================================
@@ -83,6 +98,13 @@ LOCAL_WHOLE_STATIC_LIBRARIES := $(libbcc_WHOLE_STATIC_LIBRARIES)
 
 LOCAL_WHOLE_STATIC_LIBRARIES += librsloader
 
+ifeq ($(TARGET_ARCH),x86) # We don't support x86-64 right now
+  LOCAL_WHOLE_STATIC_LIBRARIES += \
+    libsupc++ \
+    $(rs_vectorizer_STATIC_LIBRARIES)
+  LOCAL_CFLAGS += -DARCH_X86_RS_VECTORIZER
+endif
+
 LOCAL_SHARED_LIBRARIES := libbcinfo libLLVM libdl libutils libcutils liblog libstlport
 
 # Modules that need get installed if and only if the target libbcc.so is
@@ -118,6 +140,11 @@ LOCAL_WHOLE_STATIC_LIBRARIES += $(libbcc_WHOLE_STATIC_LIBRARIES)
 
 LOCAL_WHOLE_STATIC_LIBRARIES += librsloader
 
+LOCAL_WHOLE_STATIC_LIBRARIES += \
+  $(rs_vectorizer_STATIC_LIBRARIES_HOST)
+
+LOCAL_CFLAGS += -DARCH_X86_RS_VECTORIZER
+
 LOCAL_STATIC_LIBRARIES += \
   libutils \
   libcutils \
diff --git a/include/bcc/Compiler.h b/include/bcc/Compiler.h
index 5167b9a..6a42dd1 100644
--- a/include/bcc/Compiler.h
+++ b/include/bcc/Compiler.h
@@ -17,6 +17,10 @@
 #ifndef BCC_COMPILER_H
 #define BCC_COMPILER_H
 
+#ifdef ARCH_X86_RS_VECTORIZER
+#include "bcc/Renderscript/RSVectorization.h"
+#endif
+
 namespace llvm {
 
 class raw_ostream;
@@ -85,6 +89,12 @@ public:
   Compiler();
   Compiler(const CompilerConfig &pConfig);
 
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+  /// used for debug purpose for RS\Vectorizer extention
+  void dbgPoint(const char* tag, const char* title);
+  void dumpScript(const char* tag, const char* title, Script &pScript);
+#endif
+
   enum ErrorCode config(const CompilerConfig &pConfig);
 
   // Compile a script and output the result to a LLVM stream.
diff --git a/include/bcc/Renderscript/RSCompiler.h b/include/bcc/Renderscript/RSCompiler.h
index a46d558..0a12a44 100644
--- a/include/bcc/Renderscript/RSCompiler.h
+++ b/include/bcc/Renderscript/RSCompiler.h
@@ -19,9 +19,16 @@
 
 #include "bcc/Compiler.h"
 
+namespace llvm {
+  class Module;
+  class Function;
+};
+
 namespace bcc {
 
 class RSCompiler : public Compiler {
+public:
+  virtual bool performCodeTransformations(Script &pScript);
 private:
   virtual bool beforeAddLTOPasses(Script &pScript, llvm::PassManager &pPM);
   bool addInternalizeSymbolsPass(Script &pScript, llvm::PassManager &pPM);
diff --git a/include/bcc/Renderscript/RSInfo.h b/include/bcc/Renderscript/RSInfo.h
index a0a775d..43a275d 100644
--- a/include/bcc/Renderscript/RSInfo.h
+++ b/include/bcc/Renderscript/RSInfo.h
@@ -165,6 +165,8 @@ public:
   // executable file.
   static android::String8 GetPath(const char *pFilename);
 
+  static const char* GetCLCorePath();
+
   static const char LibBCCPath[];
   static const char LibCompilerRTPath[];
   static const char LibRSPath[];
diff --git a/include/bcc/Renderscript/RSVectorization.h b/include/bcc/Renderscript/RSVectorization.h
new file mode 100644
index 0000000..4714f9f
--- /dev/null
+++ b/include/bcc/Renderscript/RSVectorization.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BCC_RS_VECTORIZATION_H
+#define BCC_RS_VECTORIZATION_H
+
+#define ENABLE_VECTORIZATION_SUPPORT
+
+// turn on the hueristic
+#define __VECTORIZER_HUERISTIC
+
+#endif // BCC_RS_VECTORIZATION_H
diff --git a/include/bcc/Renderscript/RSVectorizationSupport.h b/include/bcc/Renderscript/RSVectorizationSupport.h
new file mode 100644
index 0000000..ff9f7b8
--- /dev/null
+++ b/include/bcc/Renderscript/RSVectorizationSupport.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BCC_RS_VECTORIZATION_SUPPORT_H
+#define BCC_RS_VECTORIZATION_SUPPORT_H
+
+#include "RSVectorization.h"
+#include "llvm/ADT/SmallVector.h"
+
+bool vectorizer_enabled();
+
+namespace llvm {
+  class Module;
+  class Function;
+};
+
+namespace bcc {
+
+class RSInfo;
+
+class RSVectorizationSupport {
+public:
+  static bool isVectorizerEnabled();
+  static bool prepareModuleForVectorization(const RSInfo *info, llvm::Module* M);
+  static llvm::Function* SearchForWrapperFunction(const llvm::Module& M,
+         llvm::Function* kernel);
+  static llvm::Function* SearchForVectorizedKernel( const llvm::Module& M,
+         llvm::Function* kernel);
+  static bool inlineFunctions(llvm::Module* M);
+  static bool vectorizeModule(llvm::Module& M,
+         llvm::SmallVector<llvm::Function*, 4>& vectorizedFunctions,
+         llvm::SmallVector<int, 4>& vectorizedWidths);
+
+  /// for debug usage
+  static void dumpDebugPoint(const char* tag, const char* title);
+  static void dumpDebugPoint(std::string tag, std::string title);
+  static void dumpModule(const char* tag, const char* title, llvm::Module& module);
+  static void dumpModule(std::string tag, std::string title, llvm::Module& module);
+private:
+  static bool markToInlineCalledFunctions(llvm::Function* F);
+  static bool constructGetIdBody(llvm::Module* M, llvm::Function* F);
+  static bool createGetIdFunction(llvm::Module* M, llvm::Function*& F);
+  static llvm::Function* cloneFunctionSingature(llvm::Function *F,
+         std::string clonedFunctionName);
+  static llvm::Function* createIndexedFunction(llvm::Function *F, unsigned int
+         Signature, llvm::Function* idFunc);
+  static llvm::Function* createKernelWrapper(llvm::Function* F, unsigned int
+         Signture);
+  static void doFunctionPreOptimizations(llvm::Module* M);
+  static void doFunctionPostOptimizations(llvm::Module* M);
+};
+
+} // end namespace bcc
+
+#endif // BCC_RS_VECTORIZATION_SUPPORT_H
diff --git a/lib/Core/Compiler.cpp b/lib/Core/Compiler.cpp
index 3440570..e112dab 100644
--- a/lib/Core/Compiler.cpp
+++ b/lib/Core/Compiler.cpp
@@ -34,6 +34,10 @@
 #include "bcc/Support/Log.h"
 #include "bcc/Support/OutputFile.h"
 
+#ifdef ARCH_X86_RS_VECTORIZER
+#include "bcc/Renderscript/RSVectorizationSupport.h"
+#endif
+
 using namespace bcc;
 
 const char *Compiler::GetErrorString(enum ErrorCode pErrCode) {
@@ -243,6 +247,17 @@ enum Compiler::ErrorCode Compiler::runCodeGen(Script &pScript,
   return kSuccess;
 }
 
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+void Compiler::dbgPoint(const char* tag, const char* title) {
+  RSVectorizationSupport::dumpDebugPoint(tag, title);
+}
+
+void Compiler::dumpScript(const char* tag, const char* title, Script &pScript) {
+  llvm::Module& module = pScript.getSource().getModule();
+  RSVectorizationSupport::dumpModule(tag, title, module);
+}
+#endif
+
 enum Compiler::ErrorCode Compiler::compile(Script &pScript,
                                            llvm::raw_ostream &pResult,
                                            llvm::raw_ostream *IRStream) {
diff --git a/lib/Renderscript/Android.mk b/lib/Renderscript/Android.mk
index b0ad839..ea1f6c5 100644
--- a/lib/Renderscript/Android.mk
+++ b/lib/Renderscript/Android.mk
@@ -26,7 +26,6 @@ libbcc_renderscript_SRC_FILES := \
   RSCompilerDriver.cpp \
   RSEmbedInfo.cpp \
   RSExecutable.cpp \
-  RSForEachExpand.cpp \
   RSInfo.cpp \
   RSInfoExtractor.cpp \
   RSInfoReader.cpp \
@@ -45,6 +44,14 @@ LOCAL_MODULE_CLASS := STATIC_LIBRARIES
 
 LOCAL_SRC_FILES := $(libbcc_renderscript_SRC_FILES)
 
+ifeq ($(TARGET_ARCH),x86) # We don't support x86-64 right now
+  LOCAL_CFLAGS += -DARCH_X86_RS_VECTORIZER
+  LOCAL_SRC_FILES += RSForEachExpand_x86.cpp \
+                     RSVectorizationSupport.cpp
+else
+  LOCAL_SRC_FILES += RSForEachExpand.cpp
+endif
+
 include $(LIBBCC_DEVICE_BUILD_MK)
 include $(LIBBCC_GEN_CONFIG_MK)
 include $(LLVM_DEVICE_BUILD_MK)
@@ -64,6 +71,10 @@ LOCAL_IS_HOST_MODULE := true
 
 LOCAL_SRC_FILES := $(libbcc_renderscript_SRC_FILES)
 
+LOCAL_CFLAGS += -DARCH_X86_RS_VECTORIZER
+LOCAL_SRC_FILES += RSForEachExpand_x86.cpp \
+                   RSVectorizationSupport.cpp
+
 include $(LIBBCC_HOST_BUILD_MK)
 include $(LIBBCC_GEN_CONFIG_MK)
 include $(LLVM_HOST_BUILD_MK)
diff --git a/lib/Renderscript/RSCompiler.cpp b/lib/Renderscript/RSCompiler.cpp
index 9acc455..a9b4153 100644
--- a/lib/Renderscript/RSCompiler.cpp
+++ b/lib/Renderscript/RSCompiler.cpp
@@ -27,8 +27,43 @@
 #include "bcc/Source.h"
 #include "bcc/Support/Log.h"
 
+#ifdef ARCH_X86_RS_VECTORIZER
+#include "bcc/Renderscript/RSVectorizationSupport.h"
+#endif
+
 using namespace bcc;
 
+bool RSCompiler::performCodeTransformations(Script &pScript) {
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+  if(RSVectorizationSupport::isVectorizerEnabled()) {
+    RSScript &script = static_cast<RSScript &>(pScript);
+    const RSInfo *info = script.getInfo();
+    llvm::Module &module = script.getSource().getModule();
+
+    // Materialize the bitcode module.
+    if (module.getMaterializer() != NULL) {
+      std::string error;
+      // A module with non-null materializer means that it is a lazy-load module.
+      // Materialize it now via invoking MaterializeAllPermanently(). This
+      // function returns false when the materialization is successful.
+      if (module.MaterializeAllPermanently(&error)) {
+        // If we reach this it means something happened with our script or it can't
+        // materialized, so roll-back to the scalar version without any vectorization
+        // changes on the module
+
+        ALOGW("Failed to materialize the module `%s'! (%s)",
+              module.getModuleIdentifier().c_str(), error.c_str());
+        return false;
+      }
+      return RSVectorizationSupport::prepareModuleForVectorization(info, &module);
+    }
+  }
+  return false;
+#else
+  return false;
+#endif
+}
+
 bool RSCompiler::addInternalizeSymbolsPass(Script &pScript, llvm::PassManager &pPM) {
   // Add a pass to internalize the symbols that don't need to have global
   // visibility.
diff --git a/lib/Renderscript/RSCompilerDriver.cpp b/lib/Renderscript/RSCompilerDriver.cpp
index 253c4f3..3f1b9f5 100644
--- a/lib/Renderscript/RSCompilerDriver.cpp
+++ b/lib/Renderscript/RSCompilerDriver.cpp
@@ -42,6 +42,10 @@
 #include <utils/String8.h>
 #include <utils/StopWatch.h>
 
+#ifdef ARCH_X86_RS_VECTORIZER
+#include "bcc/Renderscript/RSVectorizationSupport.h"
+#endif
+
 using namespace bcc;
 
 RSCompilerDriver::RSCompilerDriver(bool pUseCompilerRT) :
@@ -221,6 +225,38 @@ RSCompilerDriver::compileScript(RSScript &pScript,
   // to do some transformation (e.g., expand foreach-able function.)
   pScript.setInfo(info);
 
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+  //===--------------------------------------------------------------------===//
+  // Setup the config to the compiler.
+  //===--------------------------------------------------------------------===//
+  bool compiler_need_reconfigure = setupConfig(pScript);
+
+  if (mConfig == NULL) {
+    ALOGE("Failed to setup config for RS compiler to compile %s!", pOutputPath);
+    delete info;
+    return Compiler::kErrInvalidSource;
+  }
+
+  // Compiler need to re-config if it's haven't run the config() yet or the
+  // configuration it referenced is changed.
+  if (compiler_need_reconfigure) {
+    Compiler::ErrorCode err = mCompiler.config(*mConfig);
+    if (err != Compiler::kSuccess) {
+      ALOGE("Failed to config the RS compiler for %s! (%s)",pOutputPath,
+            Compiler::GetErrorString(err));
+      delete info;
+      return Compiler::kErrInvalidSource;
+    }
+  }
+
+  //===--------------------------------------------------------------------===//
+  // Perform pre-compilation transformation on the input script bitcode
+  //===--------------------------------------------------------------------===//
+  // This is required in order to make the code suitable for vectorization and
+  // before linking the builtin's implementation to the script bitcode
+  mCompiler.performCodeTransformations(pScript);
+#endif
+
   //===--------------------------------------------------------------------===//
   // Link RS script with Renderscript runtime.
   //===--------------------------------------------------------------------===//
@@ -255,6 +291,7 @@ RSCompilerDriver::compileScript(RSScript &pScript,
       return Compiler::kErrInvalidSource;
     }
 
+#ifndef ENABLE_VECTORIZATION_SUPPORT
     // Setup the config to the compiler.
     bool compiler_need_reconfigure = setupConfig(pScript);
 
@@ -272,6 +309,7 @@ RSCompilerDriver::compileScript(RSScript &pScript,
         return Compiler::kErrInvalidSource;
       }
     }
+#endif
 
     OutputFile *ir_file = NULL;
     llvm::raw_fd_ostream *IRStream = NULL;
diff --git a/lib/Renderscript/RSForEachExpand_x86.cpp b/lib/Renderscript/RSForEachExpand_x86.cpp
new file mode 100644
index 0000000..2ccf0ac
--- /dev/null
+++ b/lib/Renderscript/RSForEachExpand_x86.cpp
@@ -0,0 +1,1001 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bcc/Assert.h"
+#include "bcc/Renderscript/RSTransforms.h"
+
+#include <cstdlib>
+
+#include <llvm/IR/DerivedTypes.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/IRBuilder.h>
+#include <llvm/IR/MDBuilder.h>
+#include <llvm/IR/Module.h>
+#include <llvm/Pass.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/IR/DataLayout.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Type.h>
+#include <llvm/Transforms/Utils/BasicBlockUtils.h>
+
+#include "bcc/Config/Config.h"
+#include "bcc/Renderscript/RSInfo.h"
+#include "bcc/Support/Log.h"
+
+#include "bcinfo/MetadataExtractor.h"
+
+#include "bcc/Renderscript/RSVectorizationSupport.h"
+
+using namespace bcc;
+
+namespace {
+
+/* RSForEachExpandPass - This pass operates on functions that are able to be
+ * called via rsForEach() or "foreach_<NAME>". We create an inner loop for the
+ * ForEach-able function to be invoked over the appropriate data cells of the
+ * input/output allocations (adjusting other relevant parameters as we go). We
+ * support doing this for any ForEach-able compute kernels. The new function
+ * name is the original function name followed by ".expand". Note that we
+ * still generate code for the original function.
+ */
+class RSForEachExpandPass : public llvm::ModulePass {
+private:
+  static char ID;
+
+  llvm::Module *M;
+  llvm::LLVMContext *C;
+
+  const RSInfo::ExportForeachFuncListTy &mFuncs;
+
+  // Turns on optimization of allocation stride values.
+  bool mEnableStepOpt;
+
+  uint32_t getRootSignature(llvm::Function *F) {
+    const llvm::NamedMDNode *ExportForEachMetadata =
+        M->getNamedMetadata("#rs_export_foreach");
+
+    if (!ExportForEachMetadata) {
+      llvm::SmallVector<llvm::Type*, 8> RootArgTys;
+      for (llvm::Function::arg_iterator B = F->arg_begin(),
+                                        E = F->arg_end();
+           B != E;
+           ++B) {
+        RootArgTys.push_back(B->getType());
+      }
+
+      // For pre-ICS bitcode, we may not have signature information. In that
+      // case, we use the size of the RootArgTys to select the number of
+      // arguments.
+      return (1 << RootArgTys.size()) - 1;
+    }
+
+    if (ExportForEachMetadata->getNumOperands() == 0) {
+      return 0;
+    }
+
+    bccAssert(ExportForEachMetadata->getNumOperands() > 0);
+
+    // We only handle the case for legacy root() functions here, so this is
+    // hard-coded to look at only the first such function.
+    llvm::MDNode *SigNode = ExportForEachMetadata->getOperand(0);
+    if (SigNode != NULL && SigNode->getNumOperands() == 1) {
+      llvm::Value *SigVal = SigNode->getOperand(0);
+      if (SigVal->getValueID() == llvm::Value::MDStringVal) {
+        llvm::StringRef SigString =
+            static_cast<llvm::MDString*>(SigVal)->getString();
+        uint32_t Signature = 0;
+        if (SigString.getAsInteger(10, Signature)) {
+          ALOGE("Non-integer signature value '%s'", SigString.str().c_str());
+          return 0;
+        }
+        return Signature;
+      }
+    }
+
+    return 0;
+  }
+
+  // Get the actual value we should use to step through an allocation.
+  //
+  // Normally the value we use to step through an allocation is given to us by
+  // the driver. However, for certain primitive data types, we can derive an
+  // integer constant for the step value. We use this integer constant whenever
+  // possible to allow further compiler optimizations to take place.
+  //
+  // DL - Target Data size/layout information.
+  // T - Type of allocation (should be a pointer).
+  // OrigStep - Original step increment (root.expand() input from driver).
+  llvm::Value *getStepValue(llvm::DataLayout *DL, llvm::Type *T,
+                            llvm::Value *OrigStep) {
+    bccAssert(DL);
+    bccAssert(T);
+    bccAssert(OrigStep);
+    llvm::PointerType *PT = llvm::dyn_cast<llvm::PointerType>(T);
+    llvm::Type *VoidPtrTy = llvm::Type::getInt8PtrTy(*C);
+    if (mEnableStepOpt && T != VoidPtrTy && PT) {
+      llvm::Type *ET = PT->getElementType();
+      uint64_t ETSize = DL->getTypeAllocSize(ET);
+      llvm::Type *Int32Ty = llvm::Type::getInt32Ty(*C);
+      return llvm::ConstantInt::get(Int32Ty, ETSize);
+    } else {
+      return OrigStep;
+    }
+  }
+
+  /// @brief Returns the type of the ForEach stub parameter structure.
+  ///
+  /// Renderscript uses a single structure in which all parameters are passed
+  /// to keep the signature of the expanded function independent of the
+  /// parameters passed to it.
+  llvm::Type *getForeachStubTy() {
+    llvm::Type *VoidPtrTy = llvm::Type::getInt8PtrTy(*C);
+    llvm::Type *Int32Ty = llvm::Type::getInt32Ty(*C);
+    llvm::Type *SizeTy = Int32Ty;
+    /* Defined in frameworks/base/libs/rs/rs_hal.h:
+     *
+     * struct RsForEachStubParamStruct {
+     *   const void *in;
+     *   void *out;
+     *   const void *usr;
+     *   size_t usr_len;
+     *   uint32_t x;
+     *   uint32_t y;
+     *   uint32_t z;
+     *   uint32_t lod;
+     *   enum RsAllocationCubemapFace face;
+     *   uint32_t ar[16];
+     * };
+     */
+    llvm::SmallVector<llvm::Type*, 9> StructTys;
+    StructTys.push_back(VoidPtrTy);  // const void *in
+    StructTys.push_back(VoidPtrTy);  // void *out
+    StructTys.push_back(VoidPtrTy);  // const void *usr
+    StructTys.push_back(SizeTy);     // size_t usr_len
+    StructTys.push_back(Int32Ty);    // uint32_t x
+    StructTys.push_back(Int32Ty);    // uint32_t y
+    StructTys.push_back(Int32Ty);    // uint32_t z
+    StructTys.push_back(Int32Ty);    // uint32_t lod
+    StructTys.push_back(Int32Ty);    // enum RsAllocationCubemapFace
+    StructTys.push_back(llvm::ArrayType::get(Int32Ty, 16));  // uint32_t ar[16]
+
+    return llvm::StructType::create(StructTys, "RsForEachStubParamStruct");
+  }
+
+  /// @brief Create skeleton of the expanded function.
+  ///
+  /// This creates a function with the following signature:
+  ///
+  ///   void (const RsForEachStubParamStruct *p, uint32_t x1, uint32_t x2,
+  ///         uint32_t instep, uint32_t outstep)
+  ///
+  llvm::Function *createEmptyExpandedFunction(llvm::StringRef OldName) {
+    llvm::Type *ForEachStubPtrTy = getForeachStubTy()->getPointerTo();
+    llvm::Type *Int32Ty = llvm::Type::getInt32Ty(*C);
+
+    llvm::SmallVector<llvm::Type*, 8> ParamTys;
+    ParamTys.push_back(ForEachStubPtrTy);  // const RsForEachStubParamStruct *p
+    ParamTys.push_back(Int32Ty);           // uint32_t x1
+    ParamTys.push_back(Int32Ty);           // uint32_t x2
+    ParamTys.push_back(Int32Ty);           // uint32_t instep
+    ParamTys.push_back(Int32Ty);           // uint32_t outstep
+
+    llvm::FunctionType *FT =
+        llvm::FunctionType::get(llvm::Type::getVoidTy(*C), ParamTys, false);
+    llvm::Function *F =
+        llvm::Function::Create(FT, llvm::GlobalValue::ExternalLinkage,
+                               OldName + ".expand", M);
+
+    llvm::Function::arg_iterator AI = F->arg_begin();
+
+    AI->setName("p");
+    AI++;
+    AI->setName("x1");
+    AI++;
+    AI->setName("x2");
+    AI++;
+    AI->setName("arg_instep");
+    AI++;
+    AI->setName("arg_outstep");
+    AI++;
+
+    assert(AI == F->arg_end());
+
+    llvm::BasicBlock *Begin = llvm::BasicBlock::Create(*C, "Begin", F);
+    llvm::IRBuilder<> Builder(Begin);
+    Builder.CreateRetVoid();
+
+    return F;
+  }
+
+  /// @brief Create an empty loop
+  ///
+  /// Create a loop of the form:
+  ///
+  /// for (i = LowerBound; i < UpperBound; i++)
+  ///   ;
+  ///
+  /// After the loop has been created, the builder is set such that
+  /// instructions can be added to the loop body.
+  ///
+  /// @param Builder The builder to use to build this loop. The current
+  ///                position of the builder is the position the loop
+  ///                will be inserted.
+  /// @param LowerBound The first value of the loop iterator
+  /// @param UpperBound The maximal value of the loop iterator
+  /// @param LoopIV A reference that will be set to the loop iterator.
+  /// @return The BasicBlock that will be executed after the loop.
+
+  llvm::BasicBlock *createLoop(llvm::IRBuilder<> &Builder,
+                               llvm::Value *LowerBound,
+                               llvm::Value *UpperBound,
+                               llvm::PHINode **LoopIV) {
+    assert(LowerBound->getType() == UpperBound->getType());
+
+    llvm::BasicBlock *CondBB, *AfterBB, *HeaderBB;
+    llvm::Value *Cond, *IVNext;
+    llvm::PHINode *IV;
+
+    CondBB = Builder.GetInsertBlock();
+    AfterBB = llvm::SplitBlock(CondBB, Builder.GetInsertPoint(), this);
+    HeaderBB = llvm::BasicBlock::Create(*C, "Loop", CondBB->getParent());
+
+    // if (LowerBound < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    CondBB->getTerminator()->eraseFromParent();
+    Builder.SetInsertPoint(CondBB);
+    // if (X < x2) goto Loop; else goto Exit;
+    Cond = Builder.CreateICmpULT(LowerBound, UpperBound);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+
+    // iv = PHI [CondBB -> LowerBound], [LoopHeader -> NextIV ]
+    // iv.next = iv + 1
+    // if (iv.next < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    Builder.SetInsertPoint(HeaderBB);
+    IV = Builder.CreatePHI(LowerBound->getType(), 2, "X");
+
+    IV->addIncoming(LowerBound, CondBB);
+    IVNext = Builder.CreateNUWAdd(IV, Builder.getInt32(1));
+    IV->addIncoming(IVNext, HeaderBB);
+    Cond = Builder.CreateICmpULT(IVNext, UpperBound);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+    AfterBB->setName("Exit");
+    Builder.SetInsertPoint(HeaderBB->getFirstNonPHI());
+    *LoopIV = IV;
+    return AfterBB;
+  }
+
+/// @brief Create an empty loop for the scalar remainder
+  /// for a previously vectorized loop
+  /// Create a loop of the form:
+  ///
+  /// for (i = LowerBound; i < UpperBound; i++)
+  ///   ;
+  ///
+  /// After the loop has been created, the builder is set such that
+  /// instructions can be added to the loop body.
+  ///
+  /// @param Builder The builder to use to build this loop. The current
+  ///                position of the builder is the position the loop
+  ///                will be inserted.
+  /// @param LowerBound The first value of the loop iterator
+  /// @param UpperBound The maximal value of the loop iterator
+  /// @param LoopIV A reference that will be set to the loop iterator.
+  /// If *LoopIV != NULL, it references an existing loop iterator.
+  /// @return The BasicBlock that will be executed after the loop.
+
+  llvm::BasicBlock *createLoopS(llvm::IRBuilder<> &Builder,
+                               llvm::Value *LowerBound,
+                               llvm::Value *UpperBound,
+                               llvm::PHINode **LoopIV) {
+    assert(LowerBound->getType() == UpperBound->getType());
+
+    llvm::BasicBlock *CondBB, *AfterBB, *HeaderBB;
+    llvm::Value *Cond, *IVNext;
+    llvm::PHINode *IV;
+
+    CondBB = Builder.GetInsertBlock();
+    AfterBB = llvm::SplitBlock(CondBB, Builder.GetInsertPoint(), this);
+    HeaderBB = llvm::BasicBlock::Create(*C, "Loop", CondBB->getParent());
+
+    // if (LowerBound < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    CondBB->getTerminator()->eraseFromParent();
+    Builder.SetInsertPoint(CondBB);
+    // remainder is x2 - (x2-x1)&3
+    // if ( remainder < x2) goto Loop; else goto Exit;
+    llvm::Value *T1  = Builder.CreateSub(UpperBound, LowerBound);
+    llvm::Value *T2 = Builder.CreateAnd(T1, Builder.getInt32(3));
+    llvm::Value *Rem = Builder.CreateSub(UpperBound, T2);
+    Cond = Builder.CreateICmpULT(Rem, UpperBound);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+
+    // iv = PHI [CondBB -> Rem], [LoopHeader -> NextIV ]
+    // iv.next = iv + 1
+    // if (iv.next < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    Builder.SetInsertPoint(HeaderBB);
+    IV = Builder.CreatePHI(Rem->getType(), 2, "X");
+    *LoopIV = IV;
+
+    IV->addIncoming(LowerBound, CondBB);
+    IVNext = Builder.CreateNUWAdd(IV, Builder.getInt32(1));
+    IV->addIncoming(IVNext, HeaderBB);
+    Cond = Builder.CreateICmpULT(IVNext, UpperBound);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+    AfterBB->setName("Exit");
+    Builder.SetInsertPoint(HeaderBB->getFirstNonPHI());
+    return AfterBB;
+  }
+
+  /// @brief Create an empty loop for the vectorizer
+  ///
+  /// Create a loop of the form:
+  ///
+  /// for (i = LowerBound; i < UpperBound; i++)
+  ///   ;
+  ///
+  /// After the loop has been created, the builder is set such that
+  /// instructions can be added to the loop body.
+  ///
+  /// @param Builder The builder to use to build this loop. The current
+  ///                position of the builder is the position the loop
+  ///                will be inserted.
+  /// @param LowerBound The first value of the loop iterator
+  /// @param UpperBound The maximal value of the loop iterator
+  /// @param LoopIV A reference that will be set to the loop iterator.
+  /// @return The BasicBlock that will be executed after the loop.
+
+  llvm::BasicBlock *createLoopV(llvm::IRBuilder<> &Builder,
+                               llvm::Value *LowerBound,
+                               llvm::Value *UpperBound,
+                               llvm::PHINode **LoopIV) {
+    assert(LowerBound->getType() == UpperBound->getType());
+
+    llvm::BasicBlock *CondBB, *AfterBB, *HeaderBB;
+    llvm::Value *Cond, *IVNext;
+    llvm::PHINode *IV;
+
+    CondBB = Builder.GetInsertBlock();
+    AfterBB = llvm::SplitBlock(CondBB, Builder.GetInsertPoint(), this);
+    HeaderBB = llvm::BasicBlock::Create(*C, "Loop_V", CondBB->getParent());
+
+    // if (LowerBound < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    // For vectorization, the loop conditions are as follows:
+    // range = x2-x1
+    // x3 = range/4
+    // vrange = x3 * 4
+    CondBB->getTerminator()->eraseFromParent();
+    Builder.SetInsertPoint(CondBB);
+    llvm::Value *range  = Builder.CreateSub(UpperBound, LowerBound);
+    llvm::Value *Arg_x3 =
+        Builder.CreateSDiv(range, Builder.getInt32(4));
+    llvm::Value *v_range=
+          Builder.CreateMul(Arg_x3, Builder.getInt32(4));
+    llvm::Value *Arg_x4 =
+          Builder.CreateAdd(v_range, LowerBound);
+    Cond = Builder.CreateICmpULT(LowerBound, Arg_x4);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+
+    // iv = PHI [CondBB -> LowerBound], [LoopHeader -> NextIV ]
+    // iv.next = iv + 1
+    // if (iv.next < Upperbound)
+    //   goto LoopHeader
+    // else
+    //   goto AfterBB
+    Builder.SetInsertPoint(HeaderBB);
+    IV = Builder.CreatePHI(LowerBound->getType(), 2, "X");
+    IV->addIncoming(LowerBound, CondBB);
+    IVNext = Builder.CreateNUWAdd(IV, Builder.getInt32(4));
+    IV->addIncoming(IVNext, HeaderBB);
+    Cond = Builder.CreateICmpULT(IVNext, Arg_x4);
+    Builder.CreateCondBr(Cond, HeaderBB, AfterBB);
+    AfterBB->setName("Loop");
+    Builder.SetInsertPoint(HeaderBB->getFirstNonPHI());
+    *LoopIV = IV;
+    return AfterBB;
+  }
+
+public:
+  RSForEachExpandPass(const RSInfo::ExportForeachFuncListTy &pForeachFuncs,
+                      bool pEnableStepOpt)
+      : ModulePass(ID), M(NULL), C(NULL), mFuncs(pForeachFuncs),
+        mEnableStepOpt(pEnableStepOpt) {
+  }
+
+  /* Performs the actual optimization on a selected function. On success, the
+   * Module will contain a new function of the name "<NAME>.expand" that
+   * invokes <NAME>() in a loop with the appropriate parameters.
+   */
+bool ExpandFunction(llvm::Function* Fname, llvm::Function *F, uint32_t Signature,
+    bool useNewExpand, llvm::Function* vecKernel) {
+
+    ALOGV("Expanding ForEach-able Function %s", F->getName().str().c_str());
+
+    if (!Signature) {
+      Signature = getRootSignature(F);
+      if (!Signature) {
+        // We couldn't determine how to expand this function based on its
+        // function signature.
+        return false;
+      }
+    }
+
+    llvm::DataLayout DL(M);
+
+    llvm::Function *ExpandedFunc = createEmptyExpandedFunction(Fname->getName());
+
+    // Create and name the actual arguments to this expanded function.
+    llvm::SmallVector<llvm::Argument*, 8> ArgVec;
+    for (llvm::Function::arg_iterator B = ExpandedFunc->arg_begin(),
+                                      E = ExpandedFunc->arg_end();
+         B != E;
+         ++B) {
+      ArgVec.push_back(B);
+    }
+
+    if (ArgVec.size() != 5) {
+      ALOGE("Incorrect number of arguments to function: %zu",
+            ArgVec.size());
+      return false;
+    }
+    llvm::Value *Arg_p = ArgVec[0];
+    llvm::Value *Arg_x1 = ArgVec[1];
+    llvm::Value *Arg_x2 = ArgVec[2];
+    llvm::Value *Arg_instep = ArgVec[3];
+    llvm::Value *Arg_outstep = ArgVec[4];
+
+    llvm::Value *InStep = NULL;
+    llvm::Value *OutStep = NULL;
+
+    // Construct the actual function body.
+    llvm::IRBuilder<> Builder(ExpandedFunc->getEntryBlock().begin());
+
+    // Collect and construct the arguments for the kernel().
+    // Note that we load any loop-invariant arguments before entering the Loop.
+    llvm::Function::arg_iterator Args = F->arg_begin();
+
+    llvm::Type *InTy = NULL;
+    llvm::Value *InBasePtr = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureIn(Signature)) {
+      InTy = Args->getType();
+      InStep = getStepValue(&DL, InTy, Arg_instep);
+      InStep->setName("instep");
+      InBasePtr = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 0));
+      Args++;
+    }
+
+    llvm::Type *OutTy = NULL;
+    llvm::Value *OutBasePtr = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureOut(Signature)) {
+      OutTy = Args->getType();
+      OutStep = getStepValue(&DL, OutTy, Arg_outstep);
+      OutStep->setName("outstep");
+      OutBasePtr = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 1));
+      Args++;
+    }
+
+    llvm::Value *UsrData = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureUsrData(Signature)) {
+      llvm::Type *UsrDataTy = Args->getType();
+      UsrData = Builder.CreatePointerCast(Builder.CreateLoad(
+          Builder.CreateStructGEP(Arg_p, 2)), UsrDataTy);
+      UsrData->setName("UsrData");
+      Args++;
+    }
+
+    if (bcinfo::MetadataExtractor::hasForEachSignatureX(Signature)) {
+      Args++;
+    }
+
+    llvm::Value *Y = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureY(Signature)) {
+      Y = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 5), "Y");
+      Args++;
+    }
+
+    bccAssert(Args == F->arg_end());
+
+    llvm::Value *InPtr = NULL;
+    llvm::Value *OutPtr = NULL;
+    llvm::Value *X = NULL;
+    llvm::PHINode *IV = NULL;
+
+    // begin Vectorizer enabled call
+    if(useNewExpand)
+    {
+        llvm::BasicBlock *vBB = createLoopV(Builder, Arg_x1, Arg_x2, &IV);
+
+        // Populate the actual call to kernel().
+        llvm::SmallVector<llvm::Value*, 8> V_RootArgs;
+
+        // Calculate the current input and output pointers
+        //
+        // We always calculate the input/output pointers with a GEP operating on i8
+        // values and only cast at the very end to OutTy. This is because the step
+        // between two values is given in bytes.
+        //
+        if (OutBasePtr) {
+          llvm::Value *OutOffset = Builder.CreateSub(IV, Arg_x1);
+          OutOffset = Builder.CreateMul(OutOffset, OutStep);
+          OutOffset = Builder.CreateMul(OutOffset, Builder.getInt32(1));
+          OutPtr = Builder.CreateGEP(OutBasePtr, OutOffset);
+          OutPtr = Builder.CreatePointerCast(OutPtr, OutTy);
+        }
+        if (InBasePtr) {
+          llvm::Value *InOffset = Builder.CreateSub(IV, Arg_x1);
+          InOffset = Builder.CreateMul(InOffset, InStep);
+          InOffset = Builder.CreateMul(InOffset, Builder.getInt32(1));
+          InPtr = Builder.CreateGEP(InBasePtr, InOffset);
+          InPtr = Builder.CreatePointerCast(InPtr, InTy);
+        }
+
+        if (InPtr) {
+          V_RootArgs.push_back(InPtr);
+        }
+
+        if (OutPtr) {
+          V_RootArgs.push_back(OutPtr);
+        }
+
+        if (UsrData) {
+          V_RootArgs.push_back(UsrData);
+        }
+
+        X = IV;
+        if (bcinfo::MetadataExtractor::hasForEachSignatureX(Signature)) {
+            V_RootArgs.push_back(X);
+        }
+
+        if (Y) {
+          V_RootArgs.push_back(Y);
+        }
+
+        Builder.CreateCall(vecKernel, V_RootArgs);
+
+        // restore proper insert point
+        Builder.SetInsertPoint(vBB->getFirstNonPHI());
+        // create scalar loop to handle vectorizer remainder
+        createLoopS(Builder, Arg_x1, Arg_x2, &IV);
+    }
+    else
+        createLoop(Builder, Arg_x1, Arg_x2, &IV);
+
+    // Populate the actual call to kernel().
+    llvm::SmallVector<llvm::Value*, 8> RootArgs;
+
+    // Calculate the current input and output pointers
+    //
+    // We always calculate the input/output pointers with a GEP operating on i8
+    // values and only cast at the very end to OutTy. This is because the step
+    // between two values is given in bytes.
+    //
+    // TODO: We could further optimize the output by using a GEP operation of
+    // type 'OutTy' in cases where the element type of the allocation allows.
+    if (OutBasePtr) {
+      llvm::Value *OutOffset = Builder.CreateSub(IV, Arg_x1);
+      OutOffset = Builder.CreateMul(OutOffset, OutStep);
+      OutPtr = Builder.CreateGEP(OutBasePtr, OutOffset);
+      OutPtr = Builder.CreatePointerCast(OutPtr, OutTy);
+    }
+    if (InBasePtr) {
+      llvm::Value *InOffset = Builder.CreateSub(IV, Arg_x1);
+      InOffset = Builder.CreateMul(InOffset, InStep);
+      InPtr = Builder.CreateGEP(InBasePtr, InOffset);
+      InPtr = Builder.CreatePointerCast(InPtr, InTy);
+    }
+
+    if (InPtr) {
+      RootArgs.push_back(InPtr);
+    }
+
+    if (OutPtr) {
+      RootArgs.push_back(OutPtr);
+    }
+
+    if (UsrData) {
+      RootArgs.push_back(UsrData);
+    }
+
+    X = IV;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureX(Signature)) {
+      RootArgs.push_back(X);
+    }
+
+    if (Y) {
+      RootArgs.push_back(Y);
+    }
+
+    Builder.CreateCall(F, RootArgs);
+
+    return true;
+  }
+
+  /* Expand a pass-by-value kernel.
+   */
+  bool ExpandKernel(llvm::Function *F, uint32_t Signature) {
+    bccAssert(bcinfo::MetadataExtractor::hasForEachSignatureKernel(Signature));
+    ALOGV("Expanding kernel Function %s", F->getName().str().c_str());
+
+    // TODO: Refactor this to share functionality with ExpandFunction.
+    llvm::DataLayout DL(M);
+
+    llvm::Function *ExpandedFunc = createEmptyExpandedFunction(F->getName());
+
+    // Create and name the actual arguments to this expanded function.
+    llvm::SmallVector<llvm::Argument*, 8> ArgVec;
+    for (llvm::Function::arg_iterator B = ExpandedFunc->arg_begin(),
+                                      E = ExpandedFunc->arg_end();
+         B != E;
+         ++B) {
+      ArgVec.push_back(B);
+    }
+
+    if (ArgVec.size() != 5) {
+      ALOGE("Incorrect number of arguments to function: %zu",
+            ArgVec.size());
+      return false;
+    }
+    llvm::Value *Arg_p = ArgVec[0];
+    llvm::Value *Arg_x1 = ArgVec[1];
+    llvm::Value *Arg_x2 = ArgVec[2];
+    llvm::Value *Arg_instep = ArgVec[3];
+    llvm::Value *Arg_outstep = ArgVec[4];
+
+    llvm::Value *InStep = NULL;
+    llvm::Value *OutStep = NULL;
+
+    // Construct the actual function body.
+    llvm::IRBuilder<> Builder(ExpandedFunc->getEntryBlock().begin());
+
+    // Create TBAA meta-data.
+    llvm::MDNode *TBAARenderScript, *TBAAAllocation, *TBAAPointer;
+
+    llvm::MDBuilder MDHelper(*C);
+    TBAARenderScript = MDHelper.createTBAARoot("RenderScript TBAA");
+    TBAAAllocation = MDHelper.createTBAANode("allocation", TBAARenderScript);
+    TBAAPointer = MDHelper.createTBAANode("pointer", TBAARenderScript);
+
+    // Collect and construct the arguments for the kernel().
+    // Note that we load any loop-invariant arguments before entering the Loop.
+    llvm::Function::arg_iterator Args = F->arg_begin();
+
+    llvm::Type *OutTy = NULL;
+    bool PassOutByReference = false;
+    llvm::LoadInst *OutBasePtr = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureOut(Signature)) {
+      llvm::Type *OutBaseTy = F->getReturnType();
+      if (OutBaseTy->isVoidTy()) {
+        PassOutByReference = true;
+        OutTy = Args->getType();
+        Args++;
+      } else {
+        OutTy = OutBaseTy->getPointerTo();
+        // We don't increment Args, since we are using the actual return type.
+      }
+      OutStep = getStepValue(&DL, OutTy, Arg_outstep);
+      OutStep->setName("outstep");
+      OutBasePtr = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 1));
+      OutBasePtr->setMetadata("tbaa", TBAAPointer);
+    }
+
+    llvm::Type *InBaseTy = NULL;
+    llvm::Type *InTy = NULL;
+    llvm::LoadInst *InBasePtr = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureIn(Signature)) {
+      InBaseTy = Args->getType();
+      InTy =InBaseTy->getPointerTo();
+      InStep = getStepValue(&DL, InTy, Arg_instep);
+      InStep->setName("instep");
+      InBasePtr = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 0));
+      InBasePtr->setMetadata("tbaa", TBAAPointer);
+      Args++;
+    }
+
+    // No usrData parameter on kernels.
+    bccAssert(
+        !bcinfo::MetadataExtractor::hasForEachSignatureUsrData(Signature));
+
+    if (bcinfo::MetadataExtractor::hasForEachSignatureX(Signature)) {
+      Args++;
+    }
+
+    llvm::Value *Y = NULL;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureY(Signature)) {
+      Y = Builder.CreateLoad(Builder.CreateStructGEP(Arg_p, 5), "Y");
+      Args++;
+    }
+
+    bccAssert(Args == F->arg_end());
+
+    llvm::PHINode *IV;
+    createLoop(Builder, Arg_x1, Arg_x2, &IV);
+
+    // Populate the actual call to kernel().
+    llvm::SmallVector<llvm::Value*, 8> RootArgs;
+
+    llvm::Value *InPtr = NULL;
+    llvm::Value *OutPtr = NULL;
+
+    // Calculate the current input and output pointers
+    //
+    // We always calculate the input/output pointers with a GEP operating on i8
+    // values and only cast at the very end to OutTy. This is because the step
+    // between two values is given in bytes.
+    //
+    // TODO: We could further optimize the output by using a GEP operation of
+    // type 'OutTy' in cases where the element type of the allocation allows.
+    if (OutBasePtr) {
+      llvm::Value *OutOffset = Builder.CreateSub(IV, Arg_x1);
+      OutOffset = Builder.CreateMul(OutOffset, OutStep);
+      OutPtr = Builder.CreateGEP(OutBasePtr, OutOffset);
+      OutPtr = Builder.CreatePointerCast(OutPtr, OutTy);
+    }
+    if (InBasePtr) {
+      llvm::Value *InOffset = Builder.CreateSub(IV, Arg_x1);
+      InOffset = Builder.CreateMul(InOffset, InStep);
+      InPtr = Builder.CreateGEP(InBasePtr, InOffset);
+      InPtr = Builder.CreatePointerCast(InPtr, InTy);
+    }
+
+    if (PassOutByReference) {
+      RootArgs.push_back(OutPtr);
+    }
+
+    if (InPtr) {
+      llvm::LoadInst *In = Builder.CreateLoad(InPtr, "In");
+      In->setMetadata("tbaa", TBAAAllocation);
+      RootArgs.push_back(In);
+    }
+
+    llvm::Value *X = IV;
+    if (bcinfo::MetadataExtractor::hasForEachSignatureX(Signature)) {
+      RootArgs.push_back(X);
+    }
+
+    if (Y) {
+      RootArgs.push_back(Y);
+    }
+
+    llvm::Value *RetVal = Builder.CreateCall(F, RootArgs);
+
+    if (OutPtr && !PassOutByReference) {
+      llvm::StoreInst *Store = Builder.CreateStore(RetVal, OutPtr);
+      Store->setMetadata("tbaa", TBAAAllocation);
+    }
+
+    return true;
+  }
+
+  /// @brief Checks if pointers to allocation internals are exposed
+  ///
+  /// This function verifies if through the parameters passed to the kernel
+  /// or through calls to the runtime library the script gains access to
+  /// pointers pointing to data within a RenderScript Allocation.
+  /// If we know we control all loads from and stores to data within
+  /// RenderScript allocations and if we know the run-time internal accesses
+  /// are all annotated with RenderScript TBAA metadata, only then we
+  /// can safely use TBAA to distinguish between generic and from-allocation
+  /// pointers.
+  bool allocPointersExposed(llvm::Module &M) {
+    // Old style kernel function can expose pointers to elements within
+    // allocations.
+    // TODO: Extend analysis to allow simple cases of old-style kernels.
+    for (RSInfo::ExportForeachFuncListTy::const_iterator
+             func_iter = mFuncs.begin(), func_end = mFuncs.end();
+         func_iter != func_end; func_iter++) {
+      const char *Name = func_iter->first;
+      uint32_t Signature = func_iter->second;
+      if (M.getFunction(Name) &&
+          !bcinfo::MetadataExtractor::hasForEachSignatureKernel(Signature)) {
+        return true;
+      }
+    }
+
+    // Check for library functions that expose a pointer to an Allocation or
+    // that are not yet annotated with RenderScript-specific tbaa information.
+    static std::vector<std::string> Funcs;
+
+    // rsGetElementAt(...)
+    Funcs.push_back("_Z14rsGetElementAt13rs_allocationj");
+    Funcs.push_back("_Z14rsGetElementAt13rs_allocationjj");
+    Funcs.push_back("_Z14rsGetElementAt13rs_allocationjjj");
+    // rsSetElementAt()
+    Funcs.push_back("_Z14rsSetElementAt13rs_allocationPvj");
+    Funcs.push_back("_Z14rsSetElementAt13rs_allocationPvjj");
+    Funcs.push_back("_Z14rsSetElementAt13rs_allocationPvjjj");
+    // rsGetElementAtYuv_uchar_Y()
+    Funcs.push_back("_Z25rsGetElementAtYuv_uchar_Y13rs_allocationjj");
+    // rsGetElementAtYuv_uchar_U()
+    Funcs.push_back("_Z25rsGetElementAtYuv_uchar_U13rs_allocationjj");
+    // rsGetElementAtYuv_uchar_V()
+    Funcs.push_back("_Z25rsGetElementAtYuv_uchar_V13rs_allocationjj");
+
+    for (std::vector<std::string>::iterator FI = Funcs.begin(),
+                                            FE = Funcs.end();
+         FI != FE; ++FI) {
+      llvm::Function *F = M.getFunction(*FI);
+
+      if (!F) {
+        ALOGE("Missing run-time function '%s'", FI->c_str());
+        return true;
+      }
+
+      if (F->getNumUses() > 0) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  /// @brief Connect RenderScript TBAA metadata to C/C++ metadata
+  ///
+  /// The TBAA metadata used to annotate loads/stores from RenderScript
+  /// Allocations is generated in a separate TBAA tree with a "RenderScript TBAA"
+  /// root node. LLVM does assume may-alias for all nodes in unrelated alias
+  /// analysis trees. This function makes the RenderScript TBAA a subtree of the
+  /// normal C/C++ TBAA tree aside of normal C/C++ types. With the connected trees
+  /// every access to an Allocation is resolved to must-alias if compared to
+  /// a normal C/C++ access.
+  void connectRenderScriptTBAAMetadata(llvm::Module &M) {
+    llvm::MDBuilder MDHelper(*C);
+    llvm::MDNode *TBAARenderScript = MDHelper.createTBAARoot("RenderScript TBAA");
+
+    llvm::MDNode *TBAARoot = MDHelper.createTBAARoot("Simple C/C++ TBAA");
+    llvm::MDNode *TBAAMergedRS = MDHelper.createTBAANode("RenderScript", TBAARoot);
+
+    TBAARenderScript->replaceAllUsesWith(TBAAMergedRS);
+  }
+
+  virtual bool runOnModule(llvm::Module &M) {
+    bool Changed = false;
+    this->M = &M;
+    C = &M.getContext();
+
+    // call the vectorizer pass
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+    llvm::SmallVector<llvm::Function*, 4> vectorizedFunctions;
+    llvm::SmallVector<int, 4> vectorizedWidths;
+    if(RSVectorizationSupport::isVectorizerEnabled()) {
+        RSVectorizationSupport::vectorizeModule(M, vectorizedFunctions, vectorizedWidths);
+    }
+#endif
+
+    bool AllocsExposed = allocPointersExposed(M);
+
+    for (RSInfo::ExportForeachFuncListTy::const_iterator
+             func_iter = mFuncs.begin(), func_end = mFuncs.end();
+         func_iter != func_end; func_iter++) {
+      const char *name = func_iter->first;
+      uint32_t signature = func_iter->second;
+      llvm::Function *kernel = M.getFunction(name);
+      if (kernel) {
+        if (bcinfo::MetadataExtractor::hasForEachSignatureKernel(signature)) {
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+        bool useScalarVersion = false;
+        if(RSVectorizationSupport::isVectorizerEnabled()) {
+          // for each kernel foo we generate a wrapper that works by ptrs and return void
+          llvm::Function* wrapperFunction =
+            RSVectorizationSupport::SearchForWrapperFunction(M, kernel);
+          llvm::Function* vecWrapper = NULL;
+
+          if (NULL == wrapperFunction) {
+            ALOGW("Failed to find wrapper version for '%s'",
+              kernel->getName().str().c_str());
+            // cannot use the vectorized version
+            useScalarVersion = true;
+          }
+          else {
+            // now search for the vectorized function of the wrapper
+            vecWrapper = RSVectorizationSupport::SearchForVectorizedKernel
+                           (M, wrapperFunction);
+            if (NULL == vecWrapper) {
+              ALOGW("Failed to find x86-vectorized version for '%s'",
+                    kernel->getName().str().c_str());
+              // cannot use the vectorized version
+                useScalarVersion = true;
+            }
+          }
+
+          if(useScalarVersion) {
+            // roll-back to the normal scalar version
+          Changed |= ExpandKernel(kernel, signature);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+          }
+          else {
+            Changed |= ExpandFunction(kernel, wrapperFunction, signature, true, vecWrapper);
+            kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+          }
+        }
+        else {
+          Changed |= ExpandKernel(kernel, signature);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+        }
+#else
+          Changed |= ExpandKernel(kernel, signature);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+#endif
+        } else if (kernel->getReturnType()->isVoidTy()) {
+#ifdef ENABLE_VECTORIZATION_SUPPORT
+        if(RSVectorizationSupport::isVectorizerEnabled()) {
+          // get the vectorized function and build the new expand using it
+          llvm::Function* vecKernel = RSVectorizationSupport::SearchForVectorizedKernel
+                                        (M, kernel);
+
+          bool useNewExpand = (NULL != vecKernel) ? true : false;
+          if(!useNewExpand) {
+            ALOGW("Failed to find x86-vectorized version for '%s'",
+                  kernel->getName().str().c_str());
+          }
+
+          Changed |= ExpandFunction(kernel, kernel, signature, useNewExpand, vecKernel);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+        }
+        else {
+          Changed |= ExpandFunction(kernel, kernel, signature, false, NULL);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+        }
+#else
+          Changed |= ExpandFunction(kernel, kernel, signature, false, NULL);
+          kernel->setLinkage(llvm::GlobalValue::InternalLinkage);
+#endif
+        } else {
+          // There are some graphics root functions that are not
+          // expanded, but that will be called directly. For those
+          // functions, we can not set the linkage to internal.
+        }
+      }
+    }
+
+    if (!AllocsExposed) {
+      connectRenderScriptTBAAMetadata(M);
+    }
+
+    return Changed;
+  }
+
+  virtual const char *getPassName() const {
+    return "ForEach-able Function Expansion";
+  }
+
+}; // end RSForEachExpandPass
+
+} // end anonymous namespace
+
+char RSForEachExpandPass::ID = 0;
+
+namespace bcc {
+
+llvm::ModulePass *
+createRSForEachExpandPass(const RSInfo::ExportForeachFuncListTy &pForeachFuncs,
+                          bool pEnableStepOpt){
+  return new RSForEachExpandPass(pForeachFuncs, pEnableStepOpt);
+}
+
+} // end namespace bcc
diff --git a/lib/Renderscript/RSInfo.cpp b/lib/Renderscript/RSInfo.cpp
index cbb4af9..6926855 100644
--- a/lib/Renderscript/RSInfo.cpp
+++ b/lib/Renderscript/RSInfo.cpp
@@ -94,6 +94,16 @@ android::String8 RSInfo::GetPath(const char *pFilename) {
   return result;
 }
 
+const char* RSInfo::GetCLCorePath() {
+#if defined(ARCH_X86_HAVE_SSE2)
+  return LibCLCoreX86Path;
+#elif defined(ARCH_ARM_HAVE_NEON)
+  return LibCLCoreNEONPath;
+#else
+  return LibCLCorePath;
+#endif
+}
+
 #define PRINT_DEPENDENCY(PREFIX, N, X) \
         ALOGV("\t" PREFIX "Source name: %s, "                                 \
                           "SHA-1: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"   \
diff --git a/lib/Renderscript/RSVectorizationSupport.cpp b/lib/Renderscript/RSVectorizationSupport.cpp
new file mode 100644
index 0000000..3715fd1
--- /dev/null
+++ b/lib/Renderscript/RSVectorizationSupport.cpp
@@ -0,0 +1,1132 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bcc/Assert.h"
+#include "bcc/Renderscript/RSCompiler.h"
+#include "bcc/Renderscript/RSTransforms.h"
+#include "bcc/Renderscript/RSInfo.h"
+#include "bcc/Renderscript/RSExecutable.h"
+#include "bcc/Renderscript/RSScript.h"
+#include "bcc/Source.h"
+#include "bcc/Support/Log.h"
+#include "bcc/Support/FileBase.h"
+
+#include "bcc/Renderscript/RSVectorizationSupport.h"
+#include "bcc/Renderscript/RSVectorization.h"
+
+#ifdef HAVE_ANDROID_OS
+#include <cutils/properties.h>
+#endif
+
+#include <llvm/Analysis/Passes.h>
+#include <llvm/DebugInfo.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/DerivedTypes.h>
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/IRBuilder.h>
+#include <llvm/IR/Type.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IRReader/IRReader.h>
+#include <llvm/Pass.h>
+#include <llvm/PassManager.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/Support/SourceMgr.h>
+#include <llvm/Support/Debug.h>
+#include <llvm/Support/Casting.h>
+#include <llvm/Target/TargetMachine.h>
+#include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/Utils/Cloning.h>
+
+#include <cstdlib>
+#include <cstring>
+#include <new>
+#include <vector>
+#include <utils/String8.h>
+#include <map>
+
+// TODO[MA]: remove me
+#include <string>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+
+// begin - x86-vectorizer library api
+namespace intel {
+class OptimizerConfig;
+}
+
+extern "C" intel::OptimizerConfig* createRenderscriptConfiguration(int width);
+extern "C" void deleteRenderscriptConfiguration(intel::OptimizerConfig*& pConfig);
+
+extern "C" void* createRenderscriptRuntimeSupport(const llvm::Module *runtimeModule);
+extern "C" void* destroyRenderscriptRuntimeSupport();
+
+extern "C" llvm::Pass *createRenderscriptVectorizerPass(const llvm::Module *runtimeModule,
+  const intel::OptimizerConfig* pConfig,
+  llvm::SmallVectorImpl<llvm::Function*> &optimizerFunctions,
+  llvm::SmallVectorImpl<int> &optimizerWidths);
+
+extern "C" void* createShuffleCallToInstPass();
+extern "C" void* createPreventDivisionCrashesPass();
+// end   - x86-vectorizer library api
+
+using namespace bcc;
+
+/// -- DBG Utilities
+// These functions used for debugging
+void RSVectorizationSupport::dumpDebugPoint(const char* tag, const char* title) {
+  std::string stag = tag;
+  std::string stitle = title;
+  dumpDebugPoint(stag, stitle);
+}
+
+void RSVectorizationSupport::dumpDebugPoint(std::string tag, std::string title) {
+  static unsigned int dbg_counter = 0;
+  std::stringstream fileName;
+  fileName << "/sdcard/RS_DBGP_" << tag << "_" << title << "." << dbg_counter;
+  std::ofstream out(fileName.str().c_str());
+  ++dbg_counter;
+  out.flush();
+}
+
+void RSVectorizationSupport::dumpModule(const char* tag,
+  const char* title,
+  llvm::Module& module) {
+  std::string stag = tag;
+  std::string stitle = title;
+  dumpModule(stag, stitle, module);
+}
+
+void RSVectorizationSupport::dumpModule(std::string tag,
+  std::string title,
+  llvm::Module& module) {
+  static unsigned int pre_counter = 0;
+  std::string buffer;
+  llvm::raw_string_ostream stream(buffer);
+  std::stringstream fileName;
+  fileName << "/sdcard/RS_" << tag << "_" << title << "_" << pre_counter << ".ll";
+  std::ofstream out(fileName.str().c_str());
+  stream << module;
+  ++pre_counter;
+  stream.flush();
+  out << buffer;
+  out.flush();
+}
+/// -- DBG Utilities
+
+// TODO[MA]: remove this doublicate (need utils ?)
+
+static bool hasIn(uint32_t Signature) {
+  return Signature & 0x01;
+}
+
+static bool hasOut(uint32_t Signature) {
+  return Signature & 0x02;
+}
+
+static bool hasUsrData(uint32_t Signature) {
+  return Signature & 0x04;
+}
+
+static bool hasX(uint32_t Signature) {
+  return Signature & 0x08;
+}
+
+static bool hasY(uint32_t Signature) {
+  return Signature & 0x10;
+}
+
+static bool isKernel(uint32_t Signature) {
+  return Signature & 0x20;
+}
+// ODOT[MA]
+
+const char* g_NoInlineBuiltins[] = {
+
+  "_Z5clampDv4_fS_S_",
+  "_Z5clampDv3_fS_S_",
+  "_Z5clampDv2_fS_S_",
+  "_Z5clampfff",
+
+  "_Z5clampDv4_fff",
+  "_Z5clampDv3_fff",
+  "_Z5clampDv2_fff",
+  "_Z5clampfff",
+
+  "_Z4acosf",
+  "_Z4acosDv2_f",
+  "_Z4acosDv4_f",
+  "_Z4acosDv3_f",
+
+  "_Z5acoshf",
+  "_Z5acoshDv2_f",
+  "_Z5acoshDv4_f",
+  "_Z5acoshDv3_f",
+
+  "_Z6acospif",
+  "_Z6acospiDv2_f",
+  "_Z6acospiDv4_f",
+  "_Z6acospiDv3_f",
+
+  "_Z4asinf",
+  "_Z4asinDv2_f",
+  "_Z4asinDv4_f",
+  "_Z4asinDv3_f",
+
+  "_Z5asinhf",
+  "_Z5asinhDv2_f",
+  "_Z5asinhDv4_f",
+  "_Z5asinhDv3_f",
+
+  "_Z6asinpif",
+  "_Z6asinpiDv2_f",
+  "_Z6asinpiDv4_f",
+  "_Z6asinpiDv3_f",
+
+  "_Z4atanf",
+  "_Z4atanDv2_f",
+  "_Z4atanDv4_f",
+  "_Z4atanDv3_f",
+
+  "_Z5atan2ff",
+  "_Z5atan2Dv2_fS_",
+  "_Z5atan2Dv4_fS_",
+  "_Z5atan2Dv3_fS_",
+
+  "_Z5atanhf",
+  "_Z5atanhDv2_f",
+  "_Z5atanhDv4_f",
+  "_Z5atanhDv3_f",
+
+  "_Z6atanpif",
+  "_Z6atanpiDv2_f",
+  "_Z6atanpiDv4_f",
+  "_Z6atanpiDv3_f",
+
+  "_Z7atan2piff",
+  "_Z7atan2piDv2_fS_",
+  "_Z7atan2piDv4_fS_",
+  "_Z7atan2piDv3_fS_",
+
+  "_Z4cbrtf",
+  "_Z4cbrtDv2_f",
+  "_Z4cbrtDv4_f",
+  "_Z4cbrtDv3_f",
+
+  "_Z4ceilf",
+  "_Z4ceilDv2_f",
+  "_Z4ceilDv4_f",
+  "_Z4ceilDv3_f",
+
+  "_Z8copysignff",
+  "_Z8copysignDv2_fS_",
+  "_Z8copysignDv4_fS_",
+  "_Z8copysignDv3_fS_",
+
+  "_Z3cosf",
+  "_Z3cosDv2_f",
+  "_Z3cosDv4_f",
+  "_Z3cosDv3_f",
+
+  "_Z4coshf",
+  "_Z4coshDv2_f",
+  "_Z4coshDv4_f",
+  "_Z4coshDv3_f",
+
+  "_Z5cospif",
+  "_Z5cospiDv2_f",
+  "_Z5cospiDv4_f",
+  "_Z5cospiDv3_f",
+
+  "_Z4erfcf",
+  "_Z4erfcDv2_f",
+  "_Z4erfcDv4_f",
+ "_Z4erfcDv3_f",
+
+  "_Z3erff",
+  "_Z3erfDv2_f",
+  "_Z3erfDv4_f",
+  "_Z3erfDv3_f",
+
+  "_Z3expf",
+  "_Z3expDv2_f",
+  "_Z3expDv4_f",
+  "_Z3expDv3_f",
+
+  "_Z4exp2f",
+  "_Z4exp2Dv2_f",
+  "_Z4exp2Dv4_f",
+  "_Z4exp2Dv3_f",
+
+  "_Z5exp10f",
+  "_Z5exp10Dv2_f",
+  "_Z5exp10Dv4_f",
+  "_Z5exp10Dv3_f",
+
+  "_Z5expm1f",
+  "_Z5expm1Dv2_f",
+  "_Z5expm1Dv4_f",
+  "_Z5expm1Dv3_f",
+
+  "_Z4fabsf",
+  "_Z4fabsDv2_f",
+  "_Z4fabsDv4_f",
+  "_Z4fabsDv3_f",
+
+  "_Z4fdimff",
+  "_Z4fdimDv2_fS_",
+  "_Z4fdimDv4_fS_",
+  "_Z4fdimDv3_fS_",
+
+  "_Z5floorf",
+  "_Z5floorDv2_f",
+  "_Z5floorDv4_f",
+  "_Z5floorDv3_f",
+
+  "_Z3fmafff",
+  "_Z3fmaDv2_fS_S_",
+  "_Z3fmaDv4_fS_S_",
+  "_Z3fmaDv3_fS_S_",
+
+  "_Z4fmodff",
+  "_Z4fmodDv2_fS_",
+  "_Z4fmodDv4_fS_",
+  "_Z4fmodDv3_fS_",
+
+  "_Z5fractfPf",
+  "_Z5fractDv2_fPS_",
+  "_Z5fractDv4_fPS_",
+  "_Z5fractDv3_fPS_",
+
+  "_Z5frexpfPi",
+  "_Z5frexpDv2_fPDv2_i",
+  "_Z5frexpDv4_fPDv4_i",
+  "_Z5frexpDv3_fPDv3_i",
+
+  "_Z5hypotff",
+  "_Z5hypotDv2_fS_",
+  "_Z5hypotDv4_fS_",
+  "_Z5hypotDv3_fS_",
+
+  "_Z5ilogbf",
+  "_Z5ilogbDv2_f",
+  "_Z5ilogbDv4_f",
+  "_Z5ilogbDv3_f",
+
+  "_Z5ldexpfi",
+  "_Z5ldexpDv2_fDv2_i",
+  "_Z5ldexpDv4_fDv4_i",
+  "_Z5ldexpDv3_fDv3_i",
+
+  "_Z5ldexpfi",
+  "_Z5ldexpDv2_fi",
+  "_Z5ldexpDv4_fi",
+  "_Z5ldexpDv3_fi",
+
+  "_Z6lgammaf",
+  "_Z6lgammaDv2_f",
+  "_Z6lgammaDv4_f",
+  "_Z6lgammaDv3_f",
+
+  "_Z6lgammafPi",
+  "_Z6lgammaDv2_fPDv2_i",
+  "_Z6lgammaDv4_fPDv4_i",
+  "_Z6lgammaDv3_fPDv3_i",
+
+  "_Z3logf",
+  "_Z3logDv2_f",
+  "_Z3logDv4_f",
+  "_Z3logDv3_f",
+
+  "_Z5log10f",
+  "_Z5log10Dv2_f",
+  "_Z5log10Dv4_f",
+  "_Z5log10Dv3_f",
+
+  "_Z4log2f",
+  "_Z4log2Dv2_f",
+  "_Z4log2Dv4_f",
+  "_Z4log2Dv3_f",
+
+  "_Z5log1pf",
+  "_Z5log1pDv2_f",
+  "_Z5log1pDv4_f",
+  "_Z5log1pDv3_f",
+
+  "_Z4logbf",
+  "_Z4logbDv2_f",
+  "_Z4logbDv4_f",
+  "_Z4logbDv3_f",
+
+  "_Z4modffPf",
+  "_Z4modfDv2_fPS_",
+  "_Z4modfDv4_fPS_",
+  "_Z4modfDv3_fPS_",
+
+  "_Z9nextafterff",
+  "_Z9nextafterDv2_fS_",
+  "_Z9nextafterDv4_fS_",
+  "_Z9nextafterDv3_fS_",
+
+  "_Z3powff",
+  "_Z3powDv2_fS_",
+  "_Z3powDv4_fS_",
+  "_Z3powDv3_fS_",
+
+  "_Z4pownfi",
+  "_Z4pownDv2_fDv2_i",
+  "_Z4pownDv4_fDv4_i",
+  "_Z4pownDv3_fDv3_i",
+
+  "_Z4powrff",
+  "_Z4powrDv2_fS_",
+  "_Z4powrDv4_fS_",
+  "_Z4powrDv3_fS_",
+
+  "_Z9remainderff",
+  "_Z9remainderDv2_fS_",
+  "_Z9remainderDv4_fS_",
+  "_Z9remainderDv3_fS_",
+
+  "_Z6remquoffPi",
+  "_Z6remquoDv2_fS_PDv2_i",
+  "_Z6remquoDv4_fS_PDv4_i",
+  "_Z6remquoDv3_fS_PDv3_i",
+
+  "_Z4rintf",
+  "_Z4rintDv2_f",
+  "_Z4rintDv4_f",
+  "_Z4rintDv3_f",
+
+  "_Z5rootnfi",
+  "_Z5rootnDv2_fDv2_i",
+  "_Z5rootnDv4_fDv4_i",
+  "_Z5rootnDv3_fDv3_i",
+
+  "_Z5roundf",
+  "_Z5roundDv2_f",
+  "_Z5roundDv4_f",
+  "_Z5roundDv3_f",
+
+  "_Z5rsqrtf",
+  "_Z5rsqrtDv2_f",
+  "_Z5rsqrtDv4_f",
+  "_Z5rsqrtDv3_f",
+
+  "_Z3sinf",
+  "_Z3sinDv2_f",
+  "_Z3sinDv4_f",
+  "_Z3sinDv3_f",
+
+  "_Z6sincosfPf",
+  "_Z6sincosDv2_fPS_",
+  "_Z6sincosDv4_fPS_",
+  "_Z6sincosDv3_fPS_",
+
+  "_Z4sinhf",
+  "_Z4sinhDv2_f",
+  "_Z4sinhDv4_f",
+  "_Z4sinhDv3_f",
+
+  "_Z5sinpif",
+  "_Z5sinpiDv2_f",
+  "_Z5sinpiDv4_f",
+  "_Z5sinpiDv3_f",
+
+  "_Z3tanf",
+  "_Z3tanDv2_f",
+  "_Z3tanDv4_f",
+  "_Z3tanDv3_f",
+
+  "_Z4tanhf",
+  "_Z4tanhDv2_f",
+  "_Z4tanhDv4_f",
+  "_Z4tanhDv3_f",
+
+  "_Z5tanpif",
+  "_Z5tanpiDv2_f",
+  "_Z5tanpiDv4_f",
+  "_Z5tanpiDv3_f",
+
+  "_Z6tgammaf",
+  "_Z6tgammaDv2_f",
+  "_Z6tgammaDv4_f",
+  "_Z6tgammaDv3_f",
+
+  "_Z5truncf",
+  "_Z5truncDv2_f",
+  "_Z5truncDv4_f",
+  "_Z5truncDv3_f",
+
+  "_Z3absc",
+  "_Z3absDv2_c",
+  "_Z3absDv4_c",
+  "_Z3absDv3_c",
+
+  "_Z3abss",
+  "_Z3absDv2_s",
+  "_Z3absDv4_s",
+  "_Z3absDv3_s",
+
+  "_Z3absi",
+  "_Z3absDv2_i",
+  "_Z3absDv4_i",
+  "_Z3absDv3_i",
+
+  "_Z3clzh",
+  "_Z3clzDv2_h",
+  "_Z3clzDv4_h",
+  "_Z3clzDv3_h",
+
+  "_Z3clzc",
+  "_Z3clzDv2_c",
+  "_Z3clzDv4_c",
+  "_Z3clzDv3_c",
+
+  "_Z3clzt",
+  "_Z3clzDv2_t",
+  "_Z3clzDv4_t",
+  "_Z3clzDv3_t",
+
+  "_Z3clzs",
+  "_Z3clzDv2_s",
+  "_Z3clzDv4_s",
+  "_Z3clzDv3_s",
+
+  "_Z3clzj",
+  "_Z3clzDv2_j",
+  "_Z3clzDv4_j",
+  "_Z3clzDv3_j",
+
+  "_Z3clzi",
+  "_Z3clzDv2_i",
+  "_Z3clzDv4_i",
+  "_Z3clzDv3_i",
+
+  "_Z9half_sqrtf",
+  "_Z9half_sqrtDv2_f",
+  "_Z9half_sqrtDv4_f",
+  "_Z9half_sqrtDv3_f",
+
+  "_Z10half_rsqrtf",
+  "_Z10half_rsqrtDv2_f",
+  "_Z10half_rsqrtDv4_f",
+  "_Z10half_rsqrtDv3_f",
+
+  "_Z4sqrtf",
+  "_Z4sqrtDv2_f",
+  "_Z4sqrtDv4_f",
+  "_Z4sqrtDv3_f",
+
+  "_Z3dotff",
+  "_Z3dotDv2_fS_",
+  "_Z3dotDv4_fS_",
+  "_Z3dotDv3_fS_"
+
+  };
+
+unsigned int g_NoInlineBuiltinsNum = sizeof(g_NoInlineBuiltins) / sizeof(char*);
+
+/**
+ * run vectorizer if debug.rs.x86vectorizer is set.
+ */
+bool RSVectorizationSupport::isVectorizerEnabled() {
+#ifdef HAVE_ANDROID_OS
+  char buf[PROPERTY_VALUE_MAX];
+  property_get("debug.rs.x86vectorizer", buf, "0");
+  if ((::strcmp(buf, "1") == 0) || (::strcmp(buf, "true") == 0))
+    return true;
+  else
+    return false;
+#else
+  return true;
+#endif
+}
+
+/**
+ * constract the get id function body
+ */
+bool RSVectorizationSupport::constructGetIdBody(llvm::Module* M,
+  llvm::Function* F) {
+  bccAssert(M);
+  bccAssert(F);
+
+  // Construct the actual function body.
+  llvm::BasicBlock *BB =
+    llvm::BasicBlock::Create(M->getContext(), "", F);
+  llvm::IRBuilder<> Builder(BB);
+
+  // return 0
+  llvm::Value *idVal = llvm::ConstantInt::get(
+                         llvm::Type::getInt32Ty(M->getContext()), 0);
+  Builder.CreateRet(idVal);
+
+  return true;
+}
+
+/**
+ * creates get id function in the module; this function will serve as the
+ * induction variable function for the vectorizer
+ */
+bool RSVectorizationSupport::createGetIdFunction(llvm::Module* M,
+  llvm::Function*& F) {
+  bccAssert(M);
+  llvm::SmallVector<llvm::Type*, 8> ParamTys;
+  llvm::FunctionType *FT =
+      llvm::FunctionType::get(llvm::Type::getInt32Ty(M->getContext()), ParamTys
+      , false);
+
+  // TODO[MA]: BUG what if get.id is used in the module?
+  F = llvm::Function::Create(FT,
+                             llvm::GlobalValue::ExternalLinkage,
+                             "get.id", M);
+
+  // Construct the actual function body.
+  return constructGetIdBody(M, F);
+}
+
+/**
+ * clones the given function signture
+ */
+llvm::Function* RSVectorizationSupport::cloneFunctionSingature(llvm::Function *F,
+  std::string clonedFunctionName) {
+  llvm::SmallVector<llvm::Type*, 8> ParamTys;
+  bccAssert(F);
+
+  // get the argument types of the cloned function
+  for (llvm::Function::const_arg_iterator B = F->arg_begin(), E = F->arg_end();
+         B != E;
+         ++B) {
+    ParamTys.push_back(B->getType());
+  }
+
+  // create the new function type
+  llvm::FunctionType *FTy = llvm::FunctionType::get(
+                              F->getFunctionType()->getReturnType(),
+                              ParamTys, F->getFunctionType()->isVarArg());
+
+  // create the new function
+  std::string clonedName = clonedFunctionName.size() ? clonedFunctionName :
+                          F->getName().str() + ".clone";
+  llvm::Function *NewF = llvm::Function::Create(FTy, F->getLinkage(),
+                         clonedName, F->getParent());
+
+  // set the names of the args the same as the cloned function
+  llvm::Function::arg_iterator NewArgIt = NewF->arg_begin();
+  for (llvm::Function::const_arg_iterator B = F->arg_begin(),
+                                      E = F->arg_end();
+         B != E;
+         ++B) {
+    NewArgIt->setName(B->getName());
+    ++NewArgIt;
+  }
+
+  return NewF;
+}
+
+/**
+ * marks all the called functions from the given function F to be inlined
+ */
+bool RSVectorizationSupport::markToInlineCalledFunctions(llvm::Function* F) {
+  std::vector<llvm::Function*> toProcess, Processed;
+  toProcess.push_back(F);
+
+  while(toProcess.size() != 0) {
+    llvm::Function* pF = toProcess.back();
+    toProcess.pop_back();
+    Processed.push_back(pF);
+
+    for(llvm::Function::iterator bb = pF->begin(), bbe = pF->end();
+        bb != bbe; ++bb) {
+      for(llvm::BasicBlock::iterator i = bb->begin(), e = bb->end();
+          i != e; ++i) {
+        if (llvm::CallInst* callInst = llvm::dyn_cast<llvm::CallInst>(&*i)) {
+          // check if the call is for internal function and mark it for inlining
+          llvm::Module* M = F->getParent();
+          llvm::Function* called = callInst->getCalledFunction();
+          if (NULL != called && NULL != M->getFunction(called->getName())) {
+            called->addFnAttr(llvm::Attribute::AlwaysInline);
+            // if it's a new function then add it to the toProcess list
+            bool newItem = true;
+            for(std::vector<llvm::Function*>::iterator it = Processed.begin();
+                it != Processed.end(); ++it) {
+              if(*it == called) {
+                newItem = false;
+                break;
+              }
+            }
+            if(true == newItem) toProcess.push_back(called);
+          }
+        }
+      }
+    }
+  }
+  F->addFnAttr(llvm::Attribute::AlwaysInline);
+  return true;
+}
+
+/**
+ * creates a clone of the given function with induction variable use.
+ */
+llvm::Function* RSVectorizationSupport::createIndexedFunction(llvm::Function *F,
+  unsigned int Signature, llvm::Function* idFunc) {
+  bccAssert(F);
+  bccAssert(idFunc);
+
+  // TODO[MA]: maybe need to check if there is a recursive and roll-back
+
+  // add always inline attribute for the orignal function to get it inlined
+  // in the indexed version - assumption no recursive calls
+  RSVectorizationSupport::markToInlineCalledFunctions(F);
+
+  // clone the signture of the original function
+  std::string clonedName = F->getName().str() + ".indexed";
+  llvm::Function *indexedFunction = cloneFunctionSingature(F, clonedName);
+  if(NULL == indexedFunction) return NULL;
+
+  llvm::BasicBlock *BB = NULL;
+  BB = llvm::BasicBlock::Create(indexedFunction->getContext(),
+    "init", indexedFunction);
+
+  // Create and name the actual arguments to this indexed function.
+  llvm::SmallVector<llvm::Argument*, 8> ArgVec;
+  for (llvm::Function::arg_iterator B = indexedFunction->arg_begin(),
+                                    E = indexedFunction->arg_end();
+       B != E;
+       ++B) {
+    ArgVec.push_back(B);
+  }
+
+  // Construct the actual function body.
+  llvm::IRBuilder<> Builder(BB);
+
+  bccAssert(idFunc);
+  // Populate the actual call to get id
+  llvm::SmallVector<llvm::Value*, 8> idArgs;
+  llvm::Value* itemID = Builder.CreateCall(idFunc, idArgs);
+
+  // call the original function with the item id with the relevant arguments
+  unsigned int argCounter = 0;
+  llvm::SmallVector<llvm::Value*, 8> RootArgs;
+  if (hasIn(Signature)) {
+    llvm::Value* InPtr =
+      Builder.CreateInBoundsGEP(ArgVec[argCounter++], itemID, "inElement");
+    RootArgs.push_back(InPtr);
+  }
+
+  if (hasOut(Signature)) {
+    llvm::Value* OutPtr =
+      Builder.CreateInBoundsGEP(ArgVec[argCounter++], itemID, "outElement");
+    RootArgs.push_back(OutPtr);
+  }
+
+  if (hasUsrData(Signature)) {
+    RootArgs.push_back(ArgVec[argCounter++]);
+  }
+
+  if (hasX(Signature)) {
+    llvm::Value* currX =
+      Builder.CreateAdd(ArgVec[argCounter++], itemID, "currentX");
+    RootArgs.push_back(currX);
+  }
+
+  if (hasY(Signature)) {
+    RootArgs.push_back(ArgVec[argCounter++]);
+  }
+
+  bccAssert(argCounter == ArgVec.size());
+  // Populate the actual call to the root
+  if(F->getReturnType()->isVoidTy()) {
+    Builder.CreateCall(F, RootArgs);
+    Builder.CreateRetVoid();
+  }
+  else {
+    llvm::Value* retVal = Builder.CreateCall(F, RootArgs);
+    Builder.CreateRet(retVal);
+  }
+
+  return indexedFunction;
+}
+
+llvm::Function* RSVectorizationSupport::createKernelWrapper(llvm::Function* F,
+  unsigned int Signture) {
+  bccAssert(F);
+  llvm::SmallVector<llvm::Type*, 8> WrapperParamTys;
+
+  // add always inline attribute for the orignal function to get it inlined
+  // in the indexed version
+  F->addFnAttr(llvm::Attribute::AlwaysInline);
+
+  llvm::Function::const_arg_iterator B = F->arg_begin();
+  llvm::Function::const_arg_iterator E = F->arg_end();
+
+  if (hasOut(Signture)) {
+    llvm::Type *OutBaseTy = F->getReturnType();
+    if (OutBaseTy->isVoidTy()) {
+      // means the kernel already passing it's out by reference
+      bccAssert(B != E);
+      WrapperParamTys.push_back(B->getType());
+      B++;
+    } else {
+      // we put the return type as the first argument and move it by reference
+      WrapperParamTys.push_back(OutBaseTy->getPointerTo());
+    }
+  }
+
+  if (hasIn(Signture)) {
+    // need to get in argument by reference
+    bccAssert(B != E);
+    llvm::Type *InBaseTy = B->getType();
+    llvm::Type *InTy =InBaseTy->getPointerTo();
+    // notice that need to put "in" param at first regardless of the out param
+    WrapperParamTys.insert(WrapperParamTys.begin(), InTy);
+    B++;
+  }
+
+  // move over all the remianed argument types of the wrapped function
+  for (;
+         B != E;
+         ++B) {
+    WrapperParamTys.push_back(B->getType());
+  }
+
+  // create the new function type
+  llvm::FunctionType *FTy = llvm::FunctionType::get(
+                              llvm::Type::getVoidTy(F->getParent()->getContext()),
+                              WrapperParamTys, F->getFunctionType()->isVarArg());
+
+  // create the new function
+  llvm::Function *WrapperF = llvm::Function::Create(FTy, F->getLinkage(),
+                         F->getName().str() + ".wrapper", F->getParent());
+
+  // list the actual arguments to the orginal function.
+  llvm::SmallVector<llvm::Argument*, 8> ArgVec;
+  for (llvm::Function::arg_iterator B = F->arg_begin(),
+                                    E = F->arg_end();
+       B != E;
+       ++B) {
+    ArgVec.push_back(B);
+  }
+
+  // set the names of the args the same as the wrapped function
+  llvm::Function::arg_iterator WrapperArgIt = WrapperF->arg_begin();
+  B = F->arg_begin();
+  E = F->arg_end();
+
+  // these are the indices for in\out in the original F
+  int inIndex = (hasOut(Signture) && F->getReturnType()->isVoidTy())
+      ? 1 : 0;
+  int outIndex = (hasOut(Signture) && F->getReturnType()->isVoidTy())
+      ? 0 : -1;
+  if (hasIn(Signture)) {
+    // just adding "p" prefix for the in argument
+    bccAssert(B != E);
+    std::string inName = "p" + ArgVec[inIndex]->getName().str();
+    WrapperArgIt->setName(inName);
+    B++;
+    WrapperArgIt++;
+  }
+
+  if (hasOut(Signture)) {
+    llvm::Type *OutBaseTy = F->getReturnType();
+    if (OutBaseTy->isVoidTy()) {
+      // means the kernel passing it's out by reference
+      bccAssert(B != E);
+      WrapperArgIt->setName(ArgVec[outIndex]->getName());
+      B++;
+      WrapperArgIt++;
+    } else {
+      // BUG: if the name already in use, just keep it debug feature
+      //WrapperArgIt->setName("out");
+      WrapperArgIt++;
+    }
+  }
+
+  // get the names for the other arguments
+  for (;
+         B != E;
+         ++B) {
+    WrapperArgIt->setName(B->getName());
+    ++WrapperArgIt;
+  }
+
+  // final step: build the wrapper function body
+
+  // list the actual arguments to the wrapper function.
+  llvm::SmallVector<llvm::Argument*, 8> WrapperArgVec;
+  for (llvm::Function::arg_iterator B = WrapperF->arg_begin(),
+                                    E = WrapperF->arg_end();
+       B != E;
+       ++B) {
+    WrapperArgVec.push_back(B);
+  }
+
+  llvm::BasicBlock *BB =
+      llvm::BasicBlock::Create(WrapperF->getParent()->getContext(),
+      "init", WrapperF);
+  llvm::IRBuilder<> Builder(BB);
+
+  // call the original function with the relevant arguments
+  int wrapperInIndex = (hasIn(Signture)) ? 0 : -1;
+  int wrapperOutIndex = (hasIn(Signture)) ? 1 : 0;
+
+  unsigned int argCounter = 0;
+  llvm::SmallVector<llvm::Value*, 8> CallArgs;
+  bool outInRet = false;
+  if (hasOut(Signture)) {
+    llvm::Type *OutBaseTy = F->getReturnType();
+    if (OutBaseTy->isVoidTy()) {
+      // means the kernel passing it's out by reference
+      CallArgs.push_back(WrapperArgVec[wrapperOutIndex]);
+      argCounter++;
+    } else {
+      argCounter++;
+      outInRet = true;
+    }
+  }
+
+  if (hasIn(Signture)) {
+    llvm::Value* InValue =
+      Builder.CreateLoad(WrapperArgVec[wrapperInIndex], "Input");
+    argCounter++;
+    CallArgs.push_back(InValue);
+  }
+
+  // pass other arguments directly
+  for(unsigned int i = argCounter; i < WrapperF->arg_size(); ++i) {
+    CallArgs.push_back(WrapperArgVec[argCounter++]);
+  }
+
+  // Populate the actual call to the root
+  llvm::Value* retVal = Builder.CreateCall(F, CallArgs);
+  if(outInRet) {
+    Builder.CreateStore(retVal, WrapperArgVec[wrapperOutIndex]);
+  }
+  Builder.CreateRetVoid();
+  return WrapperF;
+}
+
+#pragma GCC push_options
+#pragma GCC optimize ("-O0")
+
+bool RSVectorizationSupport::prepareModuleForVectorization(const RSInfo *info,
+  llvm::Module* M) {
+  bccAssert(info);
+  bccAssert(M);
+
+  // in case there is no exported foreach functions no need to do anything with
+  // the given module
+  RSInfo::ExportForeachFuncListTy::const_iterator it_begin =
+    info->getExportForeachFuncs().begin();
+  RSInfo::ExportForeachFuncListTy::const_iterator it_end   =
+    info->getExportForeachFuncs().end();
+  if (it_begin == it_end) return false;
+
+  // this named metadata will contain all the indexed functions
+  // to be used by the vectorizer
+  llvm::StringRef rsIndexedKernelsMD = "rs.indexed.kernels";
+  llvm::NamedMDNode* kernels = M->getOrInsertNamedMetadata(rsIndexedKernelsMD);
+
+  // first step need to create get id function in order to use it as item-id
+  llvm::Function* idFunc = NULL;
+  createGetIdFunction(M, idFunc);
+  bccAssert(idFunc);
+
+  // iterate over all the exported foreach functions list and make indexed
+  // version for each one of them
+  const RSInfo::ExportForeachFuncListTy &foreach_func =
+      info->getExportForeachFuncs();
+  for (RSInfo::ExportForeachFuncListTy::const_iterator
+             func_iter = foreach_func.begin(), func_end = foreach_func.end();
+         func_iter != func_end; func_iter++) {
+    const char *name = func_iter->first;
+    unsigned int signature = func_iter->second;
+    llvm::Function *kernel = M->getFunction(name);
+
+    llvm::Function* indexedFunc = NULL;
+
+    if (kernel && isKernel(signature)) {
+      llvm::Function* wrapperF = createKernelWrapper(kernel, signature);
+      indexedFunc = createIndexedFunction(wrapperF, signature, idFunc);
+    }
+    else if (kernel && kernel->getReturnType()->isVoidTy()) {
+      // NOTE: this pass doesn't support getRootSignture yet
+      if(signature)
+        indexedFunc = createIndexedFunction(kernel, signature, idFunc);
+    }
+
+    if (NULL != indexedFunc) {
+      // pass the indexed function ptr to the vectorizer
+      llvm::ArrayRef<llvm::Value*> values(indexedFunc);
+      llvm::MDNode* Node = llvm::MDNode::get(M->getContext(), values);
+      kernels->addOperand(Node);
+    }
+  }
+
+  doFunctionPreOptimizations(M);
+  inlineFunctions(M);
+
+  return true;
+}
+
+#pragma GCC pop_options
+
+void RSVectorizationSupport::doFunctionPreOptimizations(llvm::Module* M) {
+  llvm::FunctionPassManager fpm = llvm::FunctionPassManager(M);
+  void* functionOptimizationPass = createShuffleCallToInstPass();
+
+  fpm.add((llvm::Pass*)functionOptimizationPass);
+
+  for(llvm::Module::iterator it = M->begin(); it != M->end(); ++it) {
+    if(it->isDeclaration()) continue;
+    fpm.run(*it);
+  }
+}
+
+void RSVectorizationSupport::doFunctionPostOptimizations(llvm::Module* M) {
+  llvm::FunctionPassManager fpm = llvm::FunctionPassManager(M);
+  void* functionOptimizationPass = createPreventDivisionCrashesPass();
+
+  fpm.add((llvm::Pass*)functionOptimizationPass);
+
+  for(llvm::Module::iterator it = M->begin(); it != M->end(); ++it) {
+    if(it->isDeclaration()) continue;
+    fpm.run(*it);
+  }
+}
+
+llvm::Function* RSVectorizationSupport::SearchForWrapperFunction(const
+  llvm::Module& M, llvm::Function* kernel) {
+  bccAssert(kernel);
+  // need to search for the wrapper function prototype for the given kernel
+  std::string suffix = ".wrapper";
+  std::string functionName = kernel->getName();
+  std::string wrapperName = functionName + suffix;
+  return M.getFunction(wrapperName);
+}
+
+llvm::Function* RSVectorizationSupport::SearchForVectorizedKernel( const
+  llvm::Module& M, llvm::Function* kernel) {
+  // need to search for the vectorized version of the specified kernel
+  // notice that if we have kernel foo we generate a tuned version foo.indexed
+  // and our vectorized version will be called __Vectorized_.foo.indexed
+  std::string prefix = "__Vectorized_.";
+  std::string suffix = ".indexed";
+  std::string kernelName = kernel->getName();
+  std::string vectorizedName = prefix + kernelName + suffix;
+
+  return M.getFunction(vectorizedName);
+}
+
+bool RSVectorizationSupport::inlineFunctions(llvm::Module* M) {
+  bccAssert(M);
+  std::string idFunctionName = "get.id";
+  llvm::Function* idFunc = M->getFunction(idFunctionName);
+
+  if(idFunc) {
+    idFunc->deleteBody();
+  }
+
+  // maps the duplicated functions to the orginal functions
+  std::map<llvm::Function*,llvm::Function*> duplicateFunctionsMap;
+
+  // point all the NoInline function list to some empty duplicate
+  // and we will return them back once we finish inlining
+  for(unsigned int i = 0; i < g_NoInlineBuiltinsNum; ++i) {
+    llvm::Function* F = M->getFunction(g_NoInlineBuiltins[i]);
+    if(NULL!= F && false == F->use_empty()) {
+      // Clone the function, so that we can hack away on it.
+      llvm::Function* duplicateFunction = cloneFunctionSingature(F, "");
+
+      F->replaceAllUsesWith(duplicateFunction);
+      duplicateFunction->deleteBody();
+
+      duplicateFunctionsMap[duplicateFunction] = F;
+    }
+  }
+
+  llvm::PassManager trans_passes;
+  trans_passes.add(llvm::createAlwaysInlinerPass());
+  trans_passes.add(llvm::createFunctionInliningPass(4096));
+  trans_passes.run(*M);
+
+  std::map<llvm::Function*,llvm::Function*>::iterator it;
+  for(it = duplicateFunctionsMap.begin();
+      it != duplicateFunctionsMap.end(); ++it) {
+    llvm::Function* hackedF  = it->first;
+    llvm::Function* orginalF = it->second;
+
+    hackedF->replaceAllUsesWith(orginalF);
+  }
+
+  if(idFunc) {
+    constructGetIdBody(M, idFunc);
+  }
+
+  return true;
+}
+
+bool RSVectorizationSupport::vectorizeModule(llvm::Module& M,
+  llvm::SmallVector<llvm::Function*, 4>& vectorizedFunctions,
+  llvm::SmallVector<int, 4>& vectorizedWidths) {
+  llvm::PassManager passes;
+
+  // shortcut if there is no indexed kernels to vectorize
+  llvm::NamedMDNode *KernelsMD = M.getNamedMetadata("rs.indexed.kernels");
+  if (NULL == KernelsMD || 0 == KernelsMD->getNumOperands()) return false;
+
+#ifdef __VECTORIZER_HUERISTIC
+  int width = 0;
+#else
+  int width = 4;
+#endif
+
+  intel::OptimizerConfig* vectorizerConfig = createRenderscriptConfiguration(width);
+  llvm::LLVMContext &BuiltinsContext = M.getContext();
+
+  llvm::SMDiagnostic Err;
+  std::auto_ptr<llvm::Module> BuiltinsModuleAuto;
+  const char* core_lib = RSInfo::GetCLCorePath();
+
+  llvm::Module* builtinsModule = llvm::ParseIRFile(RSInfo::GetCLCorePath(), Err, BuiltinsContext);
+  if(NULL == builtinsModule) {
+    ALOGE("Vectorizer driver failed to find/parse x86 built-ins library '%s'"
+          , core_lib);
+    return false;
+  }
+
+  BuiltinsModuleAuto.reset(builtinsModule);
+  createRenderscriptRuntimeSupport(BuiltinsModuleAuto.get());
+
+  // as a first integration phase inline the built-ins
+  RSVectorizationSupport::inlineFunctions(&M);
+
+  // calling the vectorizer on the script module
+  llvm::Pass *vectorizerPass = createRenderscriptVectorizerPass(BuiltinsModuleAuto.get(),
+      vectorizerConfig,
+      vectorizedFunctions,
+      vectorizedWidths);
+
+  passes.add(vectorizerPass);
+  passes.run(M);
+
+  deleteRenderscriptConfiguration(vectorizerConfig);
+  destroyRenderscriptRuntimeSupport();
+
+  doFunctionPostOptimizations(&M);
+  return true;
+}
-- 
2.7.4

