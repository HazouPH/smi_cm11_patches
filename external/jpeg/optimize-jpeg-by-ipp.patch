From 6cb4cee52a09a6d2b6e534e204281f4a19ebf671 Mon Sep 17 00:00:00 2001
From: "SUN,Jing" <jing.a.sun@intel.com>
Date: Wed, 15 Aug 2012 17:12:55 +0800
Subject: Use IPP library to optimize Libjpeg's SW JPEG encoder

BZ: 51639

Issue: Libjpeg's SW JPEG encoder is used by Camera to compress small pictures, including thumbnail pictures.
It will be great if we optimize it.

Solution: By calling IPP library to do the core encoding processes: IDCT, Quantization and Huffman coding,
the encodingspeed will be increased by 30%.

Change-Id: I2eeb0760cf2295de69ace38286a230a459622a00
Orig-Change-Id: I84fa142dc2dfa0a31201aea4a12b564c5c5403a4
Category: aosp improvement
Domain: Video.Media-jpeg
Origin: internal
Upstream-Candidate: no
Signed-off-by: SUN,Jing <jing.a.sun@intel.com>
Signed-off-by: Dan Liang <dan.liang@intel.com>

diff --git a/Android.mk b/Android.mk
index 0b8484e..ee555e5 100644
--- a/Android.mk
+++ b/Android.mk
@@ -13,6 +13,9 @@ LOCAL_SRC_FILES := \
     jfdctint.c jidctflt.c jidctfst.c jidctint.c jidctred.c jquant1.c \
     jquant2.c jutils.c jmemmgr.c jmemnobs.c armv6_idct.S
 
+LOCAL_C_INCLUDES := \
+        $(TARGET_OUT_HEADERS)/ipp
+
 ifneq (,$(TARGET_BUILD_APPS))
   # unbundled branch, built against NDK.
   LOCAL_SDK_VERSION := 17
@@ -53,6 +56,9 @@ ifeq ($(strip $(TARGET_ARCH)),mips)
   endif
 endif
 
+# enable encoding IPP optimization
+LOCAL_CFLAGS += -DIPP_ENCODE
+
 LOCAL_MODULE := libjpeg_static
 
 include $(BUILD_STATIC_LIBRARY)
@@ -76,6 +82,12 @@ else
 LOCAL_SDK_VERSION := 17
 endif
 
+LOCAL_STATIC_LIBRARIES := \
+        libippj \
+        libippi \
+        libipps \
+        libippcore
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
diff --git a/jcdctmgr.c b/jcdctmgr.c
index 61fa79b..60748a3 100644
--- a/jcdctmgr.c
+++ b/jcdctmgr.c
@@ -16,6 +16,9 @@
 #include "jpeglib.h"
 #include "jdct.h"		/* Private declarations for DCT subsystem */
 
+#ifdef IPP_ENCODE
+#include "ippj.h"
+#endif
 
 /* Private subobject for this module */
 
@@ -59,6 +62,21 @@ start_pass_fdctmgr (j_compress_ptr cinfo)
   JQUANT_TBL * qtbl;
   DCTELEM * dtbl;
 
+#ifdef IPP_ENCODE
+	Ipp8u rawqtbl[DCTSIZE2];
+	int izigzag_index[DCTSIZE2] =
+	{
+	   0,  1,  8, 16,  9,  2,  3, 10,
+	  17, 24, 32, 25, 18, 11,  4,  5,
+	  12, 19, 26, 33, 40, 48, 41, 34,
+	  27, 20, 13,  6,  7, 14, 21, 28,
+	  35, 42, 49, 56, 57, 50, 43, 36,
+	  29, 22, 15, 23, 30, 37, 44, 51,
+	  58, 59, 52, 45, 38, 31, 39, 46,
+	  53, 60, 61, 54, 47, 55, 62, 63
+	};
+#endif
+
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
     qtblno = compptr->quant_tbl_no;
@@ -81,11 +99,23 @@ start_pass_fdctmgr (j_compress_ptr cinfo)
 				      DCTSIZE2 * SIZEOF(DCTELEM));
       }
       dtbl = fdct->divisors[qtblno];
+
+#ifdef IPP_ENCODE
+      /* reorder to zig-zag, because IPPJ expect raw tables in zig-zag */
+      /* but IJG have it in natural order */
+      for(i = 0; i < DCTSIZE2; i++) {
+            rawqtbl[i] = (unsigned char)qtbl->quantval[izigzag_index[i]];
+      }
+      /* build encoder quant table */
+      ippiQuantFwdTableInit_JPEG_8u16u(rawqtbl,(Ipp16u*)dtbl);
+#else
       for (i = 0; i < DCTSIZE2; i++) {
-	dtbl[i] = ((DCTELEM) qtbl->quantval[i]) << 3;
+            dtbl[i] = ((DCTELEM) qtbl->quantval[i]) << 3;
       }
+#endif
       break;
 #endif
+
 #ifdef DCT_IFAST_SUPPORTED
     case JDCT_IFAST:
       {
@@ -176,6 +206,51 @@ start_pass_fdctmgr (j_compress_ptr cinfo)
  * blocks. The quantized coefficients are returned in coef_blocks[].
  */
 
+#ifdef IPP_ENCODE
+METHODDEF(void)
+forward_DCT_ipp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+	     JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+	     JDIMENSION start_row, JDIMENSION start_col,
+	     JDIMENSION num_blocks)
+{
+  /* This routine is heavily used, so it's worth coding it tightly. */
+  JDIMENSION  bi;
+  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
+  DCTELEM*    divisors = fdct->divisors[compptr->quant_tbl_no];
+  Ipp8u       workspace[DCTSIZE2];  /* work area for FDCT subroutine */
+  Ipp8u*      workspaceptr;
+
+  sample_data += start_row; /* fold in the vertical offset once */
+
+  for(bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE)
+  {
+    /* Load data into workspace */
+    register JSAMPROW elemptr;
+    register int      elemr;
+    register JCOEFPTR output_ptr = coef_blocks[bi];
+
+    workspaceptr = workspace;
+
+    for(elemr = 0; elemr < DCTSIZE; elemr++)
+    {
+      elemptr = sample_data[elemr] + start_col;
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+      *workspaceptr++ = GETJSAMPLE(*elemptr++);
+    }
+
+    ippiDCTQuantFwd8x8LS_JPEG_8u16s_C1R(workspace,8,output_ptr,(Ipp16u*)divisors);
+  }
+
+  return;
+} /* forward_DCT_intellib() */
+#endif
+
 METHODDEF(void)
 forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
 	     JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
@@ -356,8 +431,12 @@ jinit_forward_dct (j_compress_ptr cinfo)
   switch (cinfo->dct_method) {
 #ifdef DCT_ISLOW_SUPPORTED
   case JDCT_ISLOW:
+#ifdef IPP_ENCODE
+    fdct->pub.forward_DCT = forward_DCT_ipp;
+#else
     fdct->pub.forward_DCT = forward_DCT;
     fdct->do_dct = jpeg_fdct_islow;
+#endif
     break;
 #endif
 #ifdef DCT_IFAST_SUPPORTED
diff --git a/jchuff.c b/jchuff.c
index f235250..697ff60 100644
--- a/jchuff.c
+++ b/jchuff.c
@@ -17,7 +17,7 @@
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
-#include "jchuff.h"		/* Declarations shared with jcphuff.c */
+#include "jchuff.h"            /* Declarations shared with jcphuff.c */
 
 
 /* Expanded entropy encoder object for Huffman encoding.
@@ -30,27 +30,45 @@ typedef struct {
   INT32 put_buffer;		/* current bit-accumulation buffer */
   int put_bits;			/* # of bits now in it */
   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
+#ifdef IPP_ENCODE
+  IppiEncodeHuffmanState* pEncHuffState;
+#endif
 } savable_state;
 
 /* This macro is to work around compilers with missing or broken
  * structure assignment.  You'll need to fix this code if you have
  * such a compiler and you change MAX_COMPS_IN_SCAN.
  */
-
+#ifndef IPP_ENCODE
 #ifndef NO_STRUCT_ASSIGN
 #define ASSIGN_STATE(dest,src)  ((dest) = (src))
 #else
 #if MAX_COMPS_IN_SCAN == 4
 #define ASSIGN_STATE(dest,src)  \
-	((dest).put_buffer = (src).put_buffer, \
-	 (dest).put_bits = (src).put_bits, \
-	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
-	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
-	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
-	 (dest).last_dc_val[3] = (src).last_dc_val[3])
+  ((dest).put_buffer = (src).put_buffer, \
+   (dest).put_bits = (src).put_bits, \
+   (dest).last_dc_val[0] = (src).last_dc_val[0], \
+   (dest).last_dc_val[1] = (src).last_dc_val[1], \
+   (dest).last_dc_val[2] = (src).last_dc_val[2], \
+   (dest).last_dc_val[3] = (src).last_dc_val[3])
+#endif
+#endif
+#else
+#ifndef NO_STRUCT_ASSIGN
+#define ASSIGN_STATE(dest,src)  ((dest) = (src))
+#else
+#if MAX_COMPS_IN_SCAN == 4
+#define ASSIGN_STATE(dest,src)  \
+  ((dest).put_buffer = (src).put_buffer, \
+   (dest).put_bits = (src).put_bits, \
+   (dest).last_dc_val[0] = (src).last_dc_val[0], \
+   (dest).last_dc_val[1] = (src).last_dc_val[1], \
+   (dest).last_dc_val[2] = (src).last_dc_val[2], \
+   (dest).last_dc_val[3] = (src).last_dc_val[3]) \
+   (dest).pEncHuffState  = (src).pEncHuffState)
+#endif
 #endif
 #endif
-
 
 typedef struct {
   struct jpeg_entropy_encoder pub; /* public fields */
@@ -149,15 +167,36 @@ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
     } else {
       /* Compute derived values for Huffman tables */
       /* We may do this more than once for a table, but it's not expensive */
-      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
+#ifdef IPP_ENCODE
+      jpeg_make_c_derived_tbl_ipp(cinfo, TRUE, dctbl,
 			      & entropy->dc_derived_tbls[dctbl]);
-      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
+      jpeg_make_c_derived_tbl_ipp(cinfo, FALSE, actbl,
 			      & entropy->ac_derived_tbls[actbl]);
+#else
+      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
+				& entropy->dc_derived_tbls[dctbl]);
+      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
+				& entropy->ac_derived_tbls[actbl]);
+#endif
     }
     /* Initialize DC predictions to 0 */
     entropy->saved.last_dc_val[ci] = 0;
   }
 
+#ifdef IPP_ENCODE
+  {
+    int size = 0;
+    entropy->saved.pEncHuffState = NULL;
+
+    ippiEncodeHuffmanStateGetBufSize_JPEG_8u(&size);
+
+    entropy->saved.pEncHuffState = (IppiEncodeHuffmanState*)
+		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE, size);
+
+	ippiEncodeHuffmanStateInit_JPEG_8u(entropy->saved.pEncHuffState);
+  }
+#endif
+
   /* Initialize bit buffer to empty */
   entropy->saved.put_buffer = 0;
   entropy->saved.put_bits = 0;
@@ -175,6 +214,51 @@ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
  * Note this is also used by jcphuff.c.
  */
 
+#ifdef IPP_ENCODE
+GLOBAL(void)
+jpeg_make_c_derived_tbl_ipp (j_compress_ptr cinfo, boolean isDC, int tblno,
+			 c_derived_tbl ** pdtbl)
+{
+  JHUFF_TBL* htbl;
+  IppStatus  status;
+
+  /* Find the input Huffman table */
+  if(tblno < 0 || tblno >= NUM_HUFF_TBLS)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+
+  htbl = isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
+
+  if(htbl == NULL)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+
+  /* Allocate a workspace if we haven't already done so. */
+  if(*pdtbl == NULL)
+  {
+    int size = 0;
+
+    *pdtbl = (c_derived_tbl *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
+          SIZEOF(c_derived_tbl));
+
+    ippiEncodeHuffmanSpecGetBufSize_JPEG_8u(&size);
+
+    (*pdtbl)->pHuffTbl = (IppiEncodeHuffmanSpec*)
+      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE, size);
+  }
+
+  htbl->bits[0] = 0;
+
+  status = ippiEncodeHuffmanSpecInit_JPEG_8u(&htbl->bits[1],htbl->huffval,(*pdtbl)->pHuffTbl);
+
+  if(ippStsNoErr != status)
+  {
+    ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+  }
+
+  return;
+} /* jpeg_make_c_derived_tbl_ipp() */
+#endif
+
 GLOBAL(void)
 jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 			 c_derived_tbl ** pdtbl)
@@ -273,6 +357,26 @@ jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 	    if (! dump_buffer(state))  \
 	      { action; } }
 
+#ifdef IPP_ENCODE
+LOCAL(boolean)
+dump_buffer_ipp (working_state * state)
+/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
+{
+  struct jpeg_destination_mgr* dest = state->cinfo->dest;
+
+  dest->next_output_byte = state->next_output_byte;
+  dest->free_in_buffer   = state->free_in_buffer;
+
+  if(! (*dest->empty_output_buffer)(state->cinfo))
+    return FALSE;
+
+  /* After a successful buffer dump, must reset buffer pointers */
+  state->next_output_byte = dest->next_output_byte;
+  state->free_in_buffer   = dest->free_in_buffer;
+
+  return TRUE;
+} /* dump_buffer_intellib() */
+#endif
 
 LOCAL(boolean)
 dump_buffer (working_state * state)
@@ -335,6 +439,41 @@ emit_bits (working_state * state, unsigned int code, int size)
   return TRUE;
 }
 
+#ifdef IPP_ENCODE
+LOCAL(boolean)
+flush_bits_ipp (working_state * state)
+{
+  int currPos = 0;
+  IppStatus status;
+
+  if(state->free_in_buffer < 128)
+  {
+    dump_buffer_ipp(state);
+  }
+
+  status = ippiEncodeHuffman8x8_JPEG_16s1u_C1(
+    0,
+    state->next_output_byte,
+    state->free_in_buffer,
+    &currPos,
+    0,
+    0,
+    0,
+    state->cur.pEncHuffState,
+    1);
+
+  if(ippStsNoErr != status)
+  {
+    return FALSE;
+  }
+
+  state->next_output_byte += currPos;
+  state->free_in_buffer   -= currPos;
+
+  return TRUE;
+} /* flush_bits_ipp() */
+#endif
+
 
 LOCAL(boolean)
 flush_bits (working_state * state)
@@ -349,6 +488,43 @@ flush_bits (working_state * state)
 
 /* Encode a single block's worth of coefficients */
 
+#ifdef IPP_ENCODE
+LOCAL(boolean)
+encode_one_block_ipp (working_state * state, JCOEFPTR block, int last_dc_val,
+		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
+{
+  int currPos = 0;
+  Ipp16s lastDC = (Ipp16s)last_dc_val;
+  IppStatus status;
+
+  if(state->free_in_buffer < 128)
+  {
+    dump_buffer_ipp(state);
+  }
+
+  status = ippiEncodeHuffman8x8_JPEG_16s1u_C1(
+    block,
+    state->next_output_byte,
+    state->free_in_buffer,
+    &currPos,
+    &lastDC,
+    dctbl->pHuffTbl,
+    actbl->pHuffTbl,
+    state->cur.pEncHuffState,
+    0);
+
+  if(ippStsNoErr != status)
+  {
+    return FALSE;
+  }
+
+  state->next_output_byte += currPos;
+  state->free_in_buffer   -= currPos;
+
+  return TRUE;
+} /* encode_one_block_intellib() */
+#endif
+
 LOCAL(boolean)
 encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
@@ -446,6 +622,28 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 /*
  * Emit a restart marker & resynchronize predictions.
  */
+#ifdef IPP_ENCODE
+LOCAL(boolean)
+emit_restart_ipp (working_state * state, int restart_num)
+{
+  int ci;
+
+  if (! flush_bits_ipp(state))
+    return FALSE;
+
+  emit_byte(state, 0xFF, return FALSE);
+  emit_byte(state, JPEG_RST0 + restart_num, return FALSE);
+
+  /* Re-initialize DC predictions to 0 */
+  for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
+    state->cur.last_dc_val[ci] = 0;
+
+  /* The restart counter is not updated until we successfully write the MCU. */
+
+  return TRUE;
+}
+
+#endif
 
 LOCAL(boolean)
 emit_restart (working_state * state, int restart_num)
@@ -489,7 +687,11 @@ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Emit restart marker if needed */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
+#ifdef IPP_ENCODE
+      if (! emit_restart_ipp(&state, entropy->next_restart_num))
+#else
       if (! emit_restart(&state, entropy->next_restart_num))
+#endif
 	return FALSE;
   }
 
@@ -497,10 +699,17 @@ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
     ci = cinfo->MCU_membership[blkn];
     compptr = cinfo->cur_comp_info[ci];
+#ifdef IPP_ENCODE
+    if (! encode_one_block_ipp(&state,
+			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
+			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
+			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
+#else
     if (! encode_one_block(&state,
 			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
 			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
 			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
+#endif
       return FALSE;
     /* Update last_dc_val */
     state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
@@ -542,8 +751,13 @@ finish_pass_huff (j_compress_ptr cinfo)
   state.cinfo = cinfo;
 
   /* Flush out the last data */
+#ifdef IPP_ENCODE
+  if (! flush_bits_ipp(&state))
+    ERREXIT(cinfo, JERR_CANT_SUSPEND);
+#else
   if (! flush_bits(&state))
     ERREXIT(cinfo, JERR_CANT_SUSPEND);
+#endif
 
   /* Update state */
   cinfo->dest->next_output_byte = state.next_output_byte;
diff --git a/jchuff.h b/jchuff.h
index a9599fc..7ce66e9 100644
--- a/jchuff.h
+++ b/jchuff.h
@@ -16,6 +16,10 @@
  * Hence the magnitude should always fit in 10 or 14 bits respectively.
  */
 
+#ifdef IPP_ENCODE
+#include "ippj.h"
+#endif
+
 #if BITS_IN_JSAMPLE == 8
 #define MAX_COEF_BITS 10
 #else
@@ -28,6 +32,9 @@ typedef struct {
   unsigned int ehufco[256];	/* code for each symbol */
   char ehufsi[256];		/* length of code for each symbol */
   /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
+#ifdef IPP_ENCODE
+  IppiEncodeHuffmanSpec* pHuffTbl;
+#endif
 } c_derived_tbl;
 
 /* Short forms of external names for systems with brain-damaged linkers. */
@@ -42,6 +49,12 @@ EXTERN(void) jpeg_make_c_derived_tbl
 	JPP((j_compress_ptr cinfo, boolean isDC, int tblno,
 	     c_derived_tbl ** pdtbl));
 
+#ifdef IPP_ENCODE
+EXTERN(void) jpeg_make_c_derived_tbl_ipp
+	JPP((j_compress_ptr cinfo, boolean isDC, int tblno,
+	     c_derived_tbl ** pdtbl));
+#endif
+
 /* Generate an optimal table definition given the specified counts */
 EXTERN(void) jpeg_gen_optimal_table
 	JPP((j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[]));
diff --git a/jdatadst.c b/jdatadst.c
index 1b37181..41682e8 100644
--- a/jdatadst.c
+++ b/jdatadst.c
@@ -99,6 +99,31 @@ init_mem_destination (j_compress_ptr cinfo)
  * write it out when emptying the buffer externally.
  */
 
+#ifdef IPP_ENCODE
+METHODDEF(boolean)
+empty_output_buffer_ipp(j_compress_ptr cinfo)
+{
+  size_t bytes_to_write;
+  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+
+  if(cinfo->progressive_mode)
+  {
+    bytes_to_write = OUTPUT_BUF_SIZE;
+  } else
+  {
+    bytes_to_write = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
+  }
+
+  if(JFWRITE(dest->outfile,dest->buffer,bytes_to_write) != bytes_to_write)
+    ERREXIT(cinfo, JERR_FILE_WRITE);
+
+  dest->pub.next_output_byte = dest->buffer;
+  dest->pub.free_in_buffer   = OUTPUT_BUF_SIZE;
+
+  return TRUE;
+} /* empty_output_buffer_ipp() */
+#endif
+
 METHODDEF(boolean)
 empty_output_buffer (j_compress_ptr cinfo)
 {
@@ -206,7 +231,11 @@ jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
 
   dest = (my_dest_ptr) cinfo->dest;
   dest->pub.init_destination = init_destination;
+#ifdef IPP_ENCODE
+  dest->pub.empty_output_buffer = empty_output_buffer_ipp;
+#else
   dest->pub.empty_output_buffer = empty_output_buffer;
+#endif
   dest->pub.term_destination = term_destination;
   dest->outfile = outfile;
 }
