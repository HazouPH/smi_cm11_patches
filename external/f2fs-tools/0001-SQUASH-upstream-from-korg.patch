From f0e2e6aadc3e1a251309f045ce6f9f6c7597c242 Mon Sep 17 00:00:00 2001
From: Dan Pasanen <dan.pasanen@gmail.com>
Date: Sun, 26 Oct 2014 22:06:53 -0500
Subject: [PATCH] [SQUASH] upstream from korg

individual commits here: https://github.com/invisiblek/android_external_f2fs-tools/commits/cm-11.0

Change-Id: I6f4ed0a7ca43501f6681702b7ffec47159ac4b59
---
 VERSION                  |   4 +-
 configure.ac             |   2 +-
 fsck/f2fs.h              |  10 +-
 fsck/fsck.c              | 277 +++++++++++++++++++++++++++++++++++++----------
 fsck/fsck.h              |   2 +
 fsck/mount.c             |  46 +++++++-
 include/f2fs_fs.h        |  93 +++++++++++++++-
 lib/libf2fs.c            |  30 ++++-
 lib/libf2fs_io.c         |  11 ++
 mkfs/f2fs_format.c       | 120 +++++++++++++-------
 mkfs/f2fs_format_main.c  |   3 +-
 mkfs/f2fs_format_utils.c |  18 ++-
 scripts/tracepoint.sh    |  10 +-
 tools/f2fstat.c          |  83 ++++++++++++--
 14 files changed, 581 insertions(+), 128 deletions(-)

diff --git a/VERSION b/VERSION
index c3a3dd8..4e11b43 100644
--- a/VERSION
+++ b/VERSION
@@ -1,2 +1,2 @@
-1.2.0
-2013-10-25
+1.4.0
+2014-09-18
diff --git a/configure.ac b/configure.ac
index 0111e72..d66cb73 100644
--- a/configure.ac
+++ b/configure.ac
@@ -57,7 +57,7 @@ PKG_CHECK_MODULES([libuuid], [uuid])
 
 # Checks for header files.
 AC_CHECK_HEADERS([linux/fs.h fcntl.h mntent.h stdlib.h string.h \
-		sys/ioctl.h sys/mount.h unistd.h])
+		sys/ioctl.h sys/mount.h unistd.h linux/falloc.h])
 
 # Checks for typedefs, structures, and compiler characteristics.
 AC_C_INLINE
diff --git a/fsck/f2fs.h b/fsck/f2fs.h
index ef045e0..61885b7 100644
--- a/fsck/f2fs.h
+++ b/fsck/f2fs.h
@@ -76,6 +76,7 @@ struct seg_entry {
 	unsigned short ckpt_valid_blocks;
 	unsigned char *ckpt_valid_map;
 	unsigned char type;             /* segment type like CURSEG_XXX_TYPE */
+	unsigned char orig_type;        /* segment type like CURSEG_XXX_TYPE */
 	unsigned long long mtime;       /* modification time of the segment */
 };
 
@@ -195,6 +196,11 @@ static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)
 	return (struct sit_info *)(SM_I(sbi)->sit_info);
 }
 
+static inline void *inline_data_addr(struct f2fs_node *node_blk)
+{
+	return (void *)&(node_blk->i.i_addr[1]);
+}
+
 static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)
 {
 	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
@@ -327,9 +333,7 @@ static inline bool IS_VALID_BLK_ADDR(struct f2fs_sb_info *sbi, u32 addr)
 
 	if (addr >= F2FS_RAW_SUPER(sbi)->block_count ||
 				addr < SM_I(sbi)->main_blkaddr) {
-		DBG(0, "block addr [0x%x]\n", addr);
-		ASSERT(addr <  F2FS_RAW_SUPER(sbi)->block_count);
-		ASSERT(addr >= SM_I(sbi)->main_blkaddr);
+		ASSERT_MSG("block addr [0x%x]\n", addr);
 		return 0;
 	}
 
diff --git a/fsck/fsck.c b/fsck/fsck.c
index d0819c4..95b4028 100644
--- a/fsck/fsck.c
+++ b/fsck/fsck.c
@@ -13,10 +13,27 @@
 char *tree_mark;
 uint32_t tree_mark_size = 256;
 
-static inline int f2fs_set_main_bitmap(struct f2fs_sb_info *sbi, u32 blk)
+static inline int f2fs_set_main_bitmap(struct f2fs_sb_info *sbi, u32 blk,
+								int type)
 {
 	struct f2fs_fsck *fsck = F2FS_FSCK(sbi);
-
+	struct seg_entry *se;
+
+	se = get_seg_entry(sbi, GET_SEGNO(sbi, blk));
+	if (se->type != type) {
+		if (type == CURSEG_WARM_DATA) {
+			if (se->type != CURSEG_COLD_DATA) {
+				DBG(1, "Wrong segment type [0x%x] %x -> %x",
+						GET_SEGNO(sbi, blk), se->type,
+						CURSEG_WARM_DATA);
+				se->type = CURSEG_WARM_DATA;
+			}
+		} else {
+			DBG(1, "Wrong segment type [0x%x] %x -> %x",
+				GET_SEGNO(sbi, blk), se->type, type);
+			se->type = type;
+		}
+	}
 	return f2fs_set_bit(BLKOFF_FROM_MAIN(sbi, blk), fsck->main_area_bitmap);
 }
 
@@ -286,7 +303,7 @@ static int fsck_chk_xattr_blk(struct f2fs_sb_info *sbi, u32 ino,
 	}
 
 	*blk_cnt = *blk_cnt + 1;
-	f2fs_set_main_bitmap(sbi, ni.blk_addr);
+	f2fs_set_main_bitmap(sbi, ni.blk_addr, CURSEG_COLD_NODE);
 	DBG(2, "ino[0x%x] x_nid[0x%x]\n", ino, x_nid);
 out:
 	free(node_blk);
@@ -309,18 +326,22 @@ int fsck_chk_node_blk(struct f2fs_sb_info *sbi, struct f2fs_inode *inode,
 	if (ntype == TYPE_INODE) {
 		fsck_chk_inode_blk(sbi, nid, ftype, node_blk, blk_cnt, &ni);
 	} else {
-		f2fs_set_main_bitmap(sbi, ni.blk_addr);
-
 		switch (ntype) {
 		case TYPE_DIRECT_NODE:
+			f2fs_set_main_bitmap(sbi, ni.blk_addr,
+							CURSEG_WARM_NODE);
 			fsck_chk_dnode_blk(sbi, inode, nid, ftype, node_blk,
 					blk_cnt, &ni);
 			break;
 		case TYPE_INDIRECT_NODE:
+			f2fs_set_main_bitmap(sbi, ni.blk_addr,
+							CURSEG_COLD_NODE);
 			fsck_chk_idnode_blk(sbi, inode, ftype, node_blk,
 					blk_cnt);
 			break;
 		case TYPE_DOUBLE_INDIRECT_NODE:
+			f2fs_set_main_bitmap(sbi, ni.blk_addr,
+							CURSEG_COLD_NODE);
 			fsck_chk_didnode_blk(sbi, inode, ftype, node_blk,
 					blk_cnt);
 			break;
@@ -353,10 +374,11 @@ void fsck_chk_inode_blk(struct f2fs_sb_info *sbi, u32 nid,
 		fsck->chk.valid_inode_cnt++;
 
 	if (ftype == F2FS_FT_DIR) {
-		f2fs_set_main_bitmap(sbi, ni->blk_addr);
+		f2fs_set_main_bitmap(sbi, ni->blk_addr, CURSEG_HOT_NODE);
 	} else {
 		if (f2fs_test_main_bitmap(sbi, ni->blk_addr) == 0) {
-			f2fs_set_main_bitmap(sbi, ni->blk_addr);
+			f2fs_set_main_bitmap(sbi, ni->blk_addr,
+							CURSEG_WARM_NODE);
 			if (i_links > 1) {
 				/* First time. Create new hard link node */
 				add_into_hard_link_list(sbi, nid, i_links);
@@ -375,6 +397,7 @@ void fsck_chk_inode_blk(struct f2fs_sb_info *sbi, u32 nid,
 						"i_links= 0x%x -> 0x%x",
 						nid, i_links, i_links + 1);
 				}
+				goto check;
 			}
 			/* No need to go deep into the node */
 			return;
@@ -393,10 +416,40 @@ void fsck_chk_inode_blk(struct f2fs_sb_info *sbi, u32 nid,
 	if (ftype == F2FS_FT_CHRDEV || ftype == F2FS_FT_BLKDEV ||
 			ftype == F2FS_FT_FIFO || ftype == F2FS_FT_SOCK)
 		goto check;
-	if((node_blk->i.i_inline & F2FS_INLINE_DATA)){
+
+	if((node_blk->i.i_inline & F2FS_INLINE_DATA)) {
+		if (le32_to_cpu(node_blk->i.i_addr[0]) != 0) {
+			/* should fix this bug all the time */
+			FIX_MSG("inline_data has wrong 0'th block = %x",
+					le32_to_cpu(node_blk->i.i_addr[0]));
+			node_blk->i.i_addr[0] = 0;
+			node_blk->i.i_blocks = cpu_to_le64(*blk_cnt);
+			need_fix = 1;
+		}
+		if (!(node_blk->i.i_inline & F2FS_DATA_EXIST)) {
+			char buf[MAX_INLINE_DATA];
+			memset(buf, 0, MAX_INLINE_DATA);
+
+			if (memcmp(buf, &node_blk->i.i_addr[1],
+							MAX_INLINE_DATA)) {
+				FIX_MSG("inline_data has DATA_EXIST");
+				node_blk->i.i_inline |= F2FS_DATA_EXIST;
+				need_fix = 1;
+			}
+		}
 		DBG(3, "ino[0x%x] has inline data!\n", nid);
 		goto check;
 	}
+	if((node_blk->i.i_inline & F2FS_INLINE_DENTRY)) {
+		DBG(3, "ino[0x%x] has inline dentry!\n", nid);
+		ret = fsck_chk_inline_dentries(sbi, node_blk,
+					&child_cnt, &child_files);
+		if (ret < 0) {
+			/* should fix this bug all the time */
+			need_fix = 1;
+		}
+		goto check;
+	}
 
 	/* check data blocks in inode */
 	for (idx = 0; idx < ADDRS_PER_INODE(&node_blk->i); idx++) {
@@ -546,7 +599,9 @@ int fsck_chk_didnode_blk(struct f2fs_sb_info *sbi, struct f2fs_inode *inode,
 }
 
 static void print_dentry(__u32 depth, __u8 *name,
-		struct f2fs_dentry_block *de_blk, int idx, int last_blk)
+		unsigned long *bitmap,
+		struct f2fs_dir_entry *dentry,
+		int max, int idx, int last_blk)
 {
 	int last_de = 0;
 	int next_idx = 0;
@@ -557,12 +612,11 @@ static void print_dentry(__u32 depth, __u8 *name,
 	if (config.dbg_lv != -1)
 		return;
 
-	name_len = le16_to_cpu(de_blk->dentry[idx].name_len);
+	name_len = le16_to_cpu(dentry[idx].name_len);
 	next_idx = idx + (name_len + F2FS_SLOT_LEN - 1) / F2FS_SLOT_LEN;
 
-	bit_offset = find_next_bit((unsigned long *)de_blk->dentry_bitmap,
-			NR_DENTRY_IN_BLOCK, next_idx);
-	if (bit_offset >= NR_DENTRY_IN_BLOCK && last_blk)
+	bit_offset = find_next_bit(bitmap, max, next_idx);
+	if (bit_offset >= max && last_blk)
 		last_de = 1;
 
 	if (tree_mark_size <= depth) {
@@ -582,47 +636,69 @@ static void print_dentry(__u32 depth, __u8 *name,
 	for (i = 1; i < depth; i++)
 		printf("%c   ", tree_mark[i]);
 	printf("%c-- %s 0x%x\n", last_de ? '`' : '|',
-				name, le32_to_cpu(de_blk->dentry[idx].ino));
+				name, le32_to_cpu(dentry[idx].ino));
 }
 
-int fsck_chk_dentry_blk(struct f2fs_sb_info *sbi, u32 blk_addr,
-		u32 *child_cnt, u32 *child_files, int last_blk)
+static int __chk_dentries(struct f2fs_sb_info *sbi, u32 *child_cnt,
+			u32* child_files,
+			unsigned long *bitmap,
+			struct f2fs_dir_entry *dentry,
+			__u8 (*filenames)[F2FS_SLOT_LEN],
+			int max, int last_blk)
 {
 	struct f2fs_fsck *fsck = F2FS_FSCK(sbi);
-	int i;
-	int ret = 0;
+	enum FILE_TYPE ftype;
 	int dentries = 0;
+	u32 blk_cnt;
 	u8 *name;
 	u32 hash_code;
-	u32 blk_cnt;
 	u16 name_len;;
+	int ret = 0;
+	int fixed = 0;
+	int i;
 
-	enum FILE_TYPE ftype;
-	struct f2fs_dentry_block *de_blk;
-
-	de_blk = (struct f2fs_dentry_block *)calloc(BLOCK_SZ, 1);
-	ASSERT(de_blk != NULL);
-
-	ret = dev_read_block(de_blk, blk_addr);
-	ASSERT(ret >= 0);
-
-	fsck->dentry_depth++;
-
-	for (i = 0; i < NR_DENTRY_IN_BLOCK;) {
-		if (test_bit(i, (unsigned long *)de_blk->dentry_bitmap) == 0) {
+	for (i = 0; i < max;) {
+		if (test_bit(i, bitmap) == 0) {
 			i++;
 			continue;
 		}
-
-		name_len = le16_to_cpu(de_blk->dentry[i].name_len);
+		if (!IS_VALID_NID(sbi, le32_to_cpu(dentry[i].ino))) {
+			DBG(1, "Bad dentry 0x%x with invalid NID/ino 0x%x",
+			    i, le32_to_cpu(dentry[i].ino));
+			if (config.fix_on) {
+				FIX_MSG("Clear bad dentry 0x%x with bad ino 0x%x",
+					i, le32_to_cpu(dentry[i].ino));
+				clear_bit(i, bitmap);
+				i++;
+				fixed = 1;
+				continue;
+			}
+		}
+		ftype = dentry[i].file_type;
+		if ((ftype <= F2FS_FT_UNKNOWN || ftype > F2FS_FT_LAST_FILE_TYPE) && config.fix_on) {
+			DBG(1, "Bad dentry 0x%x with unexpected ftype 0x%x",
+			    i, ftype);
+			if (config.fix_on) {
+				FIX_MSG("Clear bad dentry 0x%x with bad ftype 0x%x",
+					i, ftype);
+				clear_bit(i, bitmap);
+				i++;
+				fixed = 1;
+				continue;
+			}
+		}
+		name_len = le16_to_cpu(dentry[i].name_len);
 		name = calloc(name_len + 1, 1);
-		memcpy(name, de_blk->filename[i], name_len);
+		memcpy(name, filenames[i], name_len);
 		hash_code = f2fs_dentry_hash((const unsigned char *)name,
 								name_len);
 
-		ASSERT(le32_to_cpu(de_blk->dentry[i].hash_code) == hash_code);
-
-		ftype = de_blk->dentry[i].file_type;
+		/* fix hash_code made by old buggy code */
+		if (le32_to_cpu(dentry[i].hash_code) != hash_code) {
+			dentry[i].hash_code = hash_code;
+			fixed = 1;
+			FIX_MSG("hash_code[%d] of %s", i, name);
+		}
 
 		/* Becareful. 'dentry.file_type' is not imode. */
 		if (ftype == F2FS_FT_DIR) {
@@ -638,32 +714,30 @@ int fsck_chk_dentry_blk(struct f2fs_sb_info *sbi, u32 blk_addr,
 
 		DBG(1, "[%3u]-[0x%x] name[%s] len[0x%x] ino[0x%x] type[0x%x]\n",
 				fsck->dentry_depth, i, name, name_len,
-				le32_to_cpu(de_blk->dentry[i].ino),
-				de_blk->dentry[i].file_type);
+				le32_to_cpu(dentry[i].ino),
+				dentry[i].file_type);
 
-		print_dentry(fsck->dentry_depth, name, de_blk, i, last_blk);
+		print_dentry(fsck->dentry_depth, name, bitmap,
+						dentry, max, i, last_blk);
 
 		blk_cnt = 1;
 		ret = fsck_chk_node_blk(sbi,
-				NULL,
-				le32_to_cpu(de_blk->dentry[i].ino),
-				ftype,
-				TYPE_INODE,
-				&blk_cnt);
+				NULL, le32_to_cpu(dentry[i].ino),
+				ftype, TYPE_INODE, &blk_cnt);
 
 		if (ret && config.fix_on) {
 			int j;
 			int slots = (name_len + F2FS_SLOT_LEN - 1) /
 				F2FS_SLOT_LEN;
 			for (j = 0; j < slots; j++)
-				clear_bit(i + j,
-					(unsigned long *)de_blk->dentry_bitmap);
+				clear_bit(i + j, bitmap);
 			FIX_MSG("Unlink [0x%x] - %s len[0x%x], type[0x%x]",
-					le32_to_cpu(de_blk->dentry[i].ino),
+					le32_to_cpu(dentry[i].ino),
 					name, name_len,
-					de_blk->dentry[i].file_type);
+					dentry[i].file_type);
 			i += slots;
 			free(name);
+			fixed = 1;
 			continue;
 		}
 
@@ -672,13 +746,68 @@ int fsck_chk_dentry_blk(struct f2fs_sb_info *sbi, u32 blk_addr,
 		*child_files = *child_files + 1;
 		free(name);
 	}
+	return fixed ? -1 : dentries;
+}
+
+int fsck_chk_inline_dentries(struct f2fs_sb_info *sbi,
+		struct f2fs_node *node_blk, u32 *child_cnt, u32 *child_files)
+{
+	struct f2fs_fsck *fsck = F2FS_FSCK(sbi);
+	struct f2fs_inline_dentry *de_blk;
+	int dentries;
+
+	de_blk = inline_data_addr(node_blk);
+	ASSERT(de_blk != NULL);
+
+	fsck->dentry_depth++;
+	dentries = __chk_dentries(sbi, child_cnt, child_files,
+			(unsigned long *)de_blk->dentry_bitmap,
+			de_blk->dentry, de_blk->filename,
+			NR_INLINE_DENTRY, 1);
+	if (dentries < 0) {
+		DBG(1, "[%3d] Inline Dentry Block Fixed hash_codes\n\n",
+			fsck->dentry_depth);
+	} else {
+		DBG(1, "[%3d] Inline Dentry Block Done : "
+				"dentries:%d in %d slots (len:%d)\n\n",
+			fsck->dentry_depth, dentries,
+			(int)NR_INLINE_DENTRY, F2FS_NAME_LEN);
+	}
+	fsck->dentry_depth--;
+	return dentries;
+}
+
+int fsck_chk_dentry_blk(struct f2fs_sb_info *sbi, u32 blk_addr,
+		u32 *child_cnt, u32 *child_files, int last_blk)
+{
+	struct f2fs_fsck *fsck = F2FS_FSCK(sbi);
+	struct f2fs_dentry_block *de_blk;
+	int dentries, ret;
 
-	DBG(1, "[%3d] Dentry Block [0x%x] Done : "
+	de_blk = (struct f2fs_dentry_block *)calloc(BLOCK_SZ, 1);
+	ASSERT(de_blk != NULL);
+
+	ret = dev_read_block(de_blk, blk_addr);
+	ASSERT(ret >= 0);
+
+	fsck->dentry_depth++;
+	dentries = __chk_dentries(sbi, child_cnt, child_files,
+			(unsigned long *)de_blk->dentry_bitmap,
+			de_blk->dentry, de_blk->filename,
+			NR_DENTRY_IN_BLOCK, last_blk);
+
+	if (dentries < 0) {
+		ret = dev_write_block(de_blk, blk_addr);
+		ASSERT(ret >= 0);
+		DBG(1, "[%3d] Dentry Block [0x%x] Fixed hash_codes\n\n",
+			fsck->dentry_depth, blk_addr);
+	} else {
+		DBG(1, "[%3d] Dentry Block [0x%x] Done : "
 				"dentries:%d in %d slots (len:%d)\n\n",
 			fsck->dentry_depth, blk_addr, dentries,
 			NR_DENTRY_IN_BLOCK, F2FS_NAME_LEN);
+	}
 	fsck->dentry_depth--;
-
 	free(de_blk);
 	return 0;
 }
@@ -714,13 +843,16 @@ int fsck_chk_data_blk(struct f2fs_sb_info *sbi, u32 blk_addr,
 		ASSERT_MSG("Duplicated data [0x%x]. pnid[0x%x] idx[0x%x]",
 				blk_addr, parent_nid, idx_in_node);
 
-	f2fs_set_main_bitmap(sbi, blk_addr);
 
 	fsck->chk.valid_blk_cnt++;
 
-	if (ftype == F2FS_FT_DIR)
+	if (ftype == F2FS_FT_DIR) {
+		f2fs_set_main_bitmap(sbi, blk_addr, CURSEG_HOT_DATA);
 		return fsck_chk_dentry_blk(sbi, blk_addr, child_cnt,
 				child_files, last_blk);
+	} else {
+		f2fs_set_main_bitmap(sbi, blk_addr, CURSEG_WARM_DATA);
+	}
 	return 0;
 }
 
@@ -734,9 +866,6 @@ void fsck_chk_orphan_node(struct f2fs_sb_info *sbi)
 	if (!is_set_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG))
 		return;
 
-	if (config.fix_on)
-		return;
-
 	start_blk = __start_cp_addr(sbi) + 1 +
 		le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);
 	orphan_blkaddr = __start_sum_addr(sbi) - 1;
@@ -750,6 +879,11 @@ void fsck_chk_orphan_node(struct f2fs_sb_info *sbi)
 		for (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {
 			nid_t ino = le32_to_cpu(orphan_blk->ino[j]);
 			DBG(1, "[%3d] ino [0x%x]\n", i, ino);
+			if (config.fix_on) {
+				FIX_MSG("Discard orphan inodes: ino [0x%x]",
+									ino);
+				continue;
+			}
 			blk_cnt = 1;
 			fsck_chk_node_blk(sbi, NULL, ino,
 					F2FS_FT_ORPHAN, TYPE_INODE, &blk_cnt);
@@ -863,6 +997,25 @@ int check_curseg_offset(struct f2fs_sb_info *sbi)
 	return 0;
 }
 
+int check_sit_types(struct f2fs_sb_info *sbi)
+{
+	struct seg_entry *se;
+	unsigned int i;
+	int err = 0;
+
+	for (i = 0; i < TOTAL_SEGS(sbi); i++) {
+		struct seg_entry *se;
+
+		se = get_seg_entry(sbi, i);
+		if (se->orig_type != se->type) {
+			FIX_MSG("Wrong segment type [0x%x] %x -> %x",
+					i, se->orig_type, se->type);
+			err = -EINVAL;
+		}
+	}
+	return err;
+}
+
 int fsck_verify(struct f2fs_sb_info *sbi)
 {
 	unsigned int i = 0;
@@ -973,13 +1126,21 @@ int fsck_verify(struct f2fs_sb_info *sbi)
 		config.bug_on = 1;
 	}
 
+	printf("[FSCK] SIT types                                     ");
+	if (check_sit_types(sbi) == 0) {
+		printf(" [Ok..]\n");
+	} else {
+		printf(" [Fail]\n");
+		ret = EXIT_ERR_CODE;
+		config.bug_on = 1;
+	}
+
 	printf("[FSCK] other corrupted bugs                          ");
 	if (config.bug_on == 0) {
 		printf(" [Ok..]\n");
 	} else {
 		printf(" [Fail]\n");
 		ret = EXIT_ERR_CODE;
-		config.bug_on = 1;
 	}
 
 	/* fix global metadata */
diff --git a/fsck/fsck.h b/fsck/fsck.h
index 64b9984..49d6d1d 100644
--- a/fsck/fsck.h
+++ b/fsck/fsck.h
@@ -93,6 +93,8 @@ extern int fsck_chk_didnode_blk(struct f2fs_sb_info *, struct f2fs_inode *,
 extern int fsck_chk_data_blk(struct f2fs_sb_info *sbi, u32, u32 *, u32 *,
 		int, enum FILE_TYPE, u32, u16, u8);
 extern int fsck_chk_dentry_blk(struct f2fs_sb_info *, u32, u32 *, u32 *, int);
+int fsck_chk_inline_dentries(struct f2fs_sb_info *, struct f2fs_node *,
+		u32 *, u32 *);
 
 extern void print_node_info(struct f2fs_node *);
 extern void print_inode_info(struct f2fs_inode *);
diff --git a/fsck/mount.c b/fsck/mount.c
index 415f977..0aca60b 100644
--- a/fsck/mount.c
+++ b/fsck/mount.c
@@ -33,6 +33,7 @@ void print_inode_info(struct f2fs_inode *inode)
 	DISP_u32(inode, i_current_depth);
 	DISP_u32(inode, i_xattr_nid);
 	DISP_u32(inode, i_flags);
+	DISP_u32(inode, i_inline);
 	DISP_u32(inode, i_pino);
 
 	if (namelen) {
@@ -132,6 +133,7 @@ void print_raw_sb_info(struct f2fs_sb_info *sbi)
 	DISP_u32(sb, node_ino);
 	DISP_u32(sb, meta_ino);
 	DISP_u32(sb, cp_payload);
+	DISP("%s", sb, version);
 	printf("\n");
 }
 
@@ -223,14 +225,50 @@ int sanity_check_raw_super(struct f2fs_super_block *raw_super)
 
 int validate_super_block(struct f2fs_sb_info *sbi, int block)
 {
-	u64 offset = (block + 1) * F2FS_SUPER_OFFSET;
+	u64 offset;
+
 	sbi->raw_super = malloc(sizeof(struct f2fs_super_block));
 
+	if (block == 0)
+		offset = F2FS_SUPER_OFFSET;
+	else
+		offset = F2FS_BLKSIZE + F2FS_SUPER_OFFSET;
+
 	if (dev_read(sbi->raw_super, offset, sizeof(struct f2fs_super_block)))
 		return -1;
 
-	if (!sanity_check_raw_super(sbi->raw_super))
+	if (!sanity_check_raw_super(sbi->raw_super)) {
+		/* get kernel version */
+		if (config.kd >= 0) {
+			dev_read_version(config.version, 0, VERSION_LEN);
+			get_kernel_version(config.version);
+		} else {
+			memset(config.version, 0, VERSION_LEN);
+		}
+
+		/* build sb version */
+		memcpy(config.sb_version, sbi->raw_super->version, VERSION_LEN);
+		get_kernel_version(config.sb_version);
+		memcpy(config.init_version, sbi->raw_super->init_version, VERSION_LEN);
+		get_kernel_version(config.init_version);
+
+		MSG(0, "Info: MKFS version\n  \"%s\"\n", config.init_version);
+		MSG(0, "Info: FSCK version\n  from \"%s\"\n    to \"%s\"\n",
+					config.sb_version, config.version);
+		if (memcmp(config.sb_version, config.version, VERSION_LEN)) {
+			int ret;
+
+			memcpy(sbi->raw_super->version,
+						config.version, VERSION_LEN);
+			ret = dev_write(sbi->raw_super, offset,
+					sizeof(struct f2fs_super_block));
+			ASSERT(ret >= 0);
+
+			config.auto_fix = 0;
+			config.fix_on = 1;
+		}
 		return 0;
+	}
 
 	free(sbi->raw_super);
 	MSG(0, "\tCan't find a valid F2FS superblock at 0x%x\n", block);
@@ -757,6 +795,7 @@ void seg_info_from_raw_sit(struct seg_entry *se,
 	memcpy(se->cur_valid_map, raw_sit->valid_map, SIT_VBLOCK_MAP_SIZE);
 	memcpy(se->ckpt_valid_map, raw_sit->valid_map, SIT_VBLOCK_MAP_SIZE);
 	se->type = GET_SIT_TYPE(raw_sit);
+	se->orig_type = GET_SIT_TYPE(raw_sit);
 	se->mtime = le64_to_cpu(raw_sit->mtime);
 }
 
@@ -1015,7 +1054,8 @@ void rewrite_sit_area_bitmap(struct f2fs_sb_info *sbi)
 		se = get_seg_entry(sbi, segno);
 		type = se->type;
 		if (type >= NO_CHECK_TYPE) {
-			ASSERT(valid_blocks);
+			ASSERT_MSG("Invalide type and valid blocks=%x,%x",
+					segno, valid_blocks);
 			type = 0;
 		}
 		sit->vblocks = cpu_to_le16((type << SIT_VBLOCKS_SHIFT) |
diff --git a/include/f2fs_fs.h b/include/f2fs_fs.h
index 8b744aa..2a4352a 100644
--- a/include/f2fs_fs.h
+++ b/include/f2fs_fs.h
@@ -5,6 +5,9 @@
  *             http://www.samsung.com/
  *
  * Dual licensed under the GPL or LGPL version 2 licenses.
+ *
+ * The byteswap codes are copied from:
+ *   samba_3_master/lib/ccan/endian/endian.h under LGPL 2.1
  */
 #ifndef __F2FS_FS_H__
 #define __F2FS_FS_H__
@@ -30,6 +33,63 @@ typedef u32		nid_t;
 typedef u8		bool;
 typedef unsigned long	pgoff_t;
 
+#if HAVE_BYTESWAP_H
+#include <byteswap.h>
+#else
+/**
+ * bswap_16 - reverse bytes in a uint16_t value.
+ * @val: value whose bytes to swap.
+ *
+ * Example:
+ *	// Output contains "1024 is 4 as two bytes reversed"
+ *	printf("1024 is %u as two bytes reversed\n", bswap_16(1024));
+ */
+static inline uint16_t bswap_16(uint16_t val)
+{
+	return ((val & (uint16_t)0x00ffU) << 8)
+		| ((val & (uint16_t)0xff00U) >> 8);
+}
+
+/**
+ * bswap_32 - reverse bytes in a uint32_t value.
+ * @val: value whose bytes to swap.
+ *
+ * Example:
+ *	// Output contains "1024 is 262144 as four bytes reversed"
+ *	printf("1024 is %u as four bytes reversed\n", bswap_32(1024));
+ */
+static inline uint32_t bswap_32(uint32_t val)
+{
+	return ((val & (uint32_t)0x000000ffUL) << 24)
+		| ((val & (uint32_t)0x0000ff00UL) <<  8)
+		| ((val & (uint32_t)0x00ff0000UL) >>  8)
+		| ((val & (uint32_t)0xff000000UL) >> 24);
+}
+#endif /* !HAVE_BYTESWAP_H */
+
+#if !HAVE_BSWAP_64
+/**
+ * bswap_64 - reverse bytes in a uint64_t value.
+ * @val: value whose bytes to swap.
+ *
+ * Example:
+ *	// Output contains "1024 is 1125899906842624 as eight bytes reversed"
+ *	printf("1024 is %llu as eight bytes reversed\n",
+ *		(unsigned long long)bswap_64(1024));
+ */
+static inline uint64_t bswap_64(uint64_t val)
+{
+	return ((val & (uint64_t)0x00000000000000ffULL) << 56)
+		| ((val & (uint64_t)0x000000000000ff00ULL) << 40)
+		| ((val & (uint64_t)0x0000000000ff0000ULL) << 24)
+		| ((val & (uint64_t)0x00000000ff000000ULL) <<  8)
+		| ((val & (uint64_t)0x000000ff00000000ULL) >>  8)
+		| ((val & (uint64_t)0x0000ff0000000000ULL) >> 24)
+		| ((val & (uint64_t)0x00ff000000000000ULL) >> 40)
+		| ((val & (uint64_t)0xff00000000000000ULL) >> 56);
+}
+#endif
+
 #if __BYTE_ORDER == __LITTLE_ENDIAN
 #define le16_to_cpu(x)	((__u16)(x))
 #define le32_to_cpu(x)	((__u32)(x))
@@ -162,6 +222,8 @@ typedef unsigned long	pgoff_t;
 #define	DEFAULT_BLOCKS_PER_SEGMENT	512
 #define DEFAULT_SEGMENTS_PER_SECTION	1
 
+#define VERSION_LEN	256
+
 enum f2fs_config_func {
 	FSCK,
 	DUMP,
@@ -178,9 +240,12 @@ struct f2fs_configuration {
 	u_int64_t total_sectors;
 	u_int32_t sectors_per_blk;
 	u_int32_t blks_per_seg;
+	__u8 init_version[VERSION_LEN + 1];
+	__u8 sb_version[VERSION_LEN + 1];
+	__u8 version[VERSION_LEN + 1];
 	char *vol_label;
 	int heap;
-	int32_t fd;
+	int32_t fd, kd;
 	int32_t dump_fd;
 	char *device_name;
 	char *extension_list;
@@ -291,6 +356,8 @@ struct f2fs_super_block {
 	__le32 extension_count;		/* # of extensions below */
 	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
 	__le32 cp_payload;
+	__u8 version[VERSION_LEN];	/* the kernel version */
+	__u8 init_version[VERSION_LEN];	/* the initial kernel version */
 } __attribute__((packed));
 
 /*
@@ -371,6 +438,9 @@ struct f2fs_extent {
 
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
 #define F2FS_INLINE_DATA	0x02	/* file inline data flag */
+#define F2FS_INLINE_DENTRY	0x04	/* file inline dentry flag */
+#define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
+
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))
 
@@ -643,6 +713,24 @@ struct f2fs_dentry_block {
 	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];
 } __attribute__((packed));
 
+/* for inline dir */
+#define NR_INLINE_DENTRY	(MAX_INLINE_DATA * BITS_PER_BYTE / \
+				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
+				BITS_PER_BYTE + 1))
+#define INLINE_DENTRY_BITMAP_SIZE	((NR_INLINE_DENTRY + \
+					BITS_PER_BYTE - 1) / BITS_PER_BYTE)
+#define INLINE_RESERVED_SIZE	(MAX_INLINE_DATA - \
+				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
+				NR_INLINE_DENTRY + INLINE_DENTRY_BITMAP_SIZE))
+
+/* inline directory entry structure */
+struct f2fs_inline_dentry {
+	__u8 dentry_bitmap[INLINE_DENTRY_BITMAP_SIZE];
+	__u8 reserved[INLINE_RESERVED_SIZE];
+	struct f2fs_dir_entry dentry[NR_INLINE_DENTRY];
+	__u8 filename[NR_INLINE_DENTRY][F2FS_SLOT_LEN];
+} __packed;
+
 /* file types used in inode_info->flags */
 enum FILE_TYPE {
 	F2FS_FT_UNKNOWN,
@@ -657,6 +745,7 @@ enum FILE_TYPE {
 	/* added for fsck */
 	F2FS_FT_ORPHAN,
 	F2FS_FT_XATTR,
+	F2FS_FT_LAST_FILE_TYPE = F2FS_FT_XATTR,
 };
 
 /* from f2fs/segment.h */
@@ -699,6 +788,8 @@ extern int dev_fill(void *, __u64, size_t);
 extern int dev_read_block(void *, __u64);
 extern int dev_read_blocks(void *, __u64, __u32 );
 
+extern int dev_read_version(void *, __u64, size_t);
+extern void get_kernel_version(__u8 *);
 f2fs_hash_t f2fs_dentry_hash(const unsigned char *, int);
 
 extern struct f2fs_configuration config;
diff --git a/lib/libf2fs.c b/lib/libf2fs.c
index 651138e..1a4c808 100644
--- a/lib/libf2fs.c
+++ b/lib/libf2fs.c
@@ -424,10 +424,23 @@ int f2fs_dev_is_umounted(struct f2fs_configuration *c)
 }
 #endif
 
+void get_kernel_version(__u8 *version)
+{
+	int i;
+	for (i = 0; i < VERSION_LEN; i++) {
+		if (version[i] == '\n')
+			break;
+	}
+	memset(version + i, 0, VERSION_LEN + 1 - i);
+}
+
 int f2fs_get_device_info(struct f2fs_configuration *c)
 {
 	int32_t fd = 0;
 	uint32_t sector_size;
+#ifndef BLKGETSIZE64
+	uint32_t total_sectors;
+#endif
 	struct stat stat_buf;
 	struct hd_geometry geom;
 	u_int64_t wanted_total_sectors = c->total_sectors;
@@ -439,6 +452,10 @@ int f2fs_get_device_info(struct f2fs_configuration *c)
 	}
 	c->fd = fd;
 
+	c->kd = open("/proc/version", O_RDONLY);
+	if (c->kd < 0)
+		MSG(0, "\tInfo: No support kernel version!\n");
+
 	if (fstat(fd, &stat_buf) < 0 ) {
 		MSG(0, "\tError: Failed to get the device stat!\n");
 		return -1;
@@ -460,11 +477,20 @@ int f2fs_get_device_info(struct f2fs_configuration *c)
 			}
 		}
 
-		if (ioctl(fd, BLKGETSIZE, &c->total_sectors) < 0) {
+#ifdef BLKGETSIZE64
+		if (ioctl(fd, BLKGETSIZE64, &c->total_sectors) < 0) {
 			MSG(0, "\tError: Cannot get the device size\n");
 			return -1;
 		}
-
+		c->total_sectors /= c->sector_size;
+#else
+		if (ioctl(fd, BLKGETSIZE, &total_sectors) < 0) {
+			MSG(0, "\tError: Cannot get the device size\n");
+			return -1;
+		}
+		total_sectors /= c->sector_size;
+		c->total_sectors = total_sectors;
+#endif
 		if (ioctl(fd, HDIO_GETGEO, &geom) < 0)
 			c->start_sector = 0;
 		else
diff --git a/lib/libf2fs_io.c b/lib/libf2fs_io.c
index 7cd71de..aa0e43d 100644
--- a/lib/libf2fs_io.c
+++ b/lib/libf2fs_io.c
@@ -32,6 +32,15 @@ struct f2fs_configuration config;
 /*
  * IO interfaces
  */
+int dev_read_version(void *buf, __u64 offset, size_t len)
+{
+	if (lseek64(config.kd, (off64_t)offset, SEEK_SET) < 0)
+		return -1;
+	if (read(config.kd, buf, len) < 0)
+		return -1;
+	return 0;
+}
+
 int dev_read(void *buf, __u64 offset, size_t len)
 {
 	if (lseek64(config.fd, (off64_t)offset, SEEK_SET) < 0)
@@ -97,4 +106,6 @@ void f2fs_finalize_device(struct f2fs_configuration *c)
 
 	if (close(c->fd) < 0)
 		MSG(0, "\tError: Failed to close device file!!!\n");
+
+	close(c->kd);
 }
diff --git a/mkfs/f2fs_format.c b/mkfs/f2fs_format.c
index e09baf5..f82e2ed 100644
--- a/mkfs/f2fs_format.c
+++ b/mkfs/f2fs_format.c
@@ -76,7 +76,7 @@ static void configure_extension_list(void)
 		memcpy(super_block.extension_list[i++], *extlist, name_len);
 		extlist++;
 	}
-	super_block.extension_count = i;
+	super_block.extension_count = cpu_to_le32(i);
 
 	if (!ext_str)
 		return;
@@ -91,7 +91,7 @@ static void configure_extension_list(void)
 			break;
 	}
 
-	super_block.extension_count = i;
+	super_block.extension_count = cpu_to_le32(i);
 
 	free(config.extension_list);
 }
@@ -253,7 +253,7 @@ static int f2fs_prepare_super_block(void)
 	if (max_sit_bitmap_size >
 			(CHECKSUM_OFFSET - sizeof(struct f2fs_checkpoint) + 65)) {
 		max_nat_bitmap_size = CHECKSUM_OFFSET - sizeof(struct f2fs_checkpoint) + 1;
-		super_block.cp_payload = F2FS_BLK_ALIGN(max_sit_bitmap_size);
+		super_block.cp_payload = cpu_to_le32(F2FS_BLK_ALIGN(max_sit_bitmap_size));
 	} else {
 		max_nat_bitmap_size = CHECKSUM_OFFSET - sizeof(struct f2fs_checkpoint) + 1
 			- max_sit_bitmap_size;
@@ -392,6 +392,18 @@ static int f2fs_prepare_super_block(void)
 
 	configure_extension_list();
 
+	/* get kernel version */
+	if (config.kd >= 0) {
+		dev_read_version(config.version, 0, VERSION_LEN);
+		get_kernel_version(config.version);
+		MSG(0, "Info: format version with\n  \"%s\"\n", config.version);
+	} else {
+		memset(config.version, 0, VERSION_LEN);
+	}
+
+	memcpy(super_block.version, config.version, VERSION_LEN);
+	memcpy(super_block.init_version, config.version, VERSION_LEN);
+
 	return 0;
 }
 
@@ -476,6 +488,8 @@ static int f2fs_write_check_point_pack(void)
 	u_int32_t crc = 0;
 	unsigned int i;
 	char *cp_payload = NULL;
+	char *sum_buf, *sum_buf_ptr;
+	struct f2fs_summary *sum_entry;
 
 	ckp = calloc(F2FS_BLKSIZE, 1);
 	if (ckp == NULL) {
@@ -489,6 +503,13 @@ static int f2fs_write_check_point_pack(void)
 		return -1;
 	}
 
+	sum_buf = calloc(F2FS_BLKSIZE, 1);
+	if (sum == NULL) {
+		MSG(1, "\tError: Calloc Failed for summay buffer!!!\n");
+		return -1;
+	}
+	sum_buf_ptr = sum_buf;
+
 	cp_payload = calloc(F2FS_BLKSIZE, 1);
 	if (cp_payload == NULL) {
 		MSG(1, "\tError: Calloc Failed for cp_payload!!!\n");
@@ -533,9 +554,10 @@ static int f2fs_write_check_point_pack(void)
 			((le32_to_cpu(ckp->free_segment_count) + 6 -
 			le32_to_cpu(ckp->overprov_segment_count)) *
 			 config.blks_per_seg));
+	/* cp page (2), data summaries (1), node summaries (3) */
 	ckp->cp_pack_total_block_count =
-		cpu_to_le32(8 + le32_to_cpu(super_block.cp_payload));
-	ckp->ckpt_flags = cpu_to_le32(CP_UMOUNT_FLAG);
+		cpu_to_le32(6 + le32_to_cpu(super_block.cp_payload));
+	ckp->ckpt_flags = cpu_to_le32(CP_UMOUNT_FLAG | CP_COMPACT_SUM_FLAG);
 	ckp->cp_pack_start_sum = cpu_to_le32(1 + le32_to_cpu(super_block.cp_payload));
 	ckp->valid_node_count = cpu_to_le32(1);
 	ckp->valid_inode_count = cpu_to_le32(1);
@@ -574,35 +596,36 @@ static int f2fs_write_check_point_pack(void)
 		}
 	}
 
-	/* 2. Prepare and write Segment summary for data blocks */
+	/* Prepare and write Segment summary for HOT/WARM/COLD DATA
+	 *
+	 * The structure of compact summary
+	 * +-------------------+
+	 * | nat_journal       |
+	 * +-------------------+
+	 * | sit_journal       |
+	 * +-------------------+
+	 * | hot data summary  |
+	 * +-------------------+
+	 * | warm data summary |
+	 * +-------------------+
+	 * | cold data summary |
+	 * +-------------------+
+	*/
 	memset(sum, 0, sizeof(struct f2fs_summary_block));
 	SET_SUM_TYPE((&sum->footer), SUM_TYPE_DATA);
 
-	sum->entries[0].nid = super_block.root_ino;
-	sum->entries[0].ofs_in_node = 0;
-
-	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting segment summary for data, ckp at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
-	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
-		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
-		return -1;
-	}
-
-	/* 3. Fill segment summary for data block to zero. */
-	memset(sum, 0, sizeof(struct f2fs_summary_block));
-	SET_SUM_TYPE((&sum->footer), SUM_TYPE_DATA);
+	sum->n_nats = cpu_to_le16(1);
+	sum->nat_j.entries[0].nid = super_block.root_ino;
+	sum->nat_j.entries[0].ne.version = 0;
+	sum->nat_j.entries[0].ne.ino = super_block.root_ino;
+	sum->nat_j.entries[0].ne.block_addr = cpu_to_le32(
+			le32_to_cpu(super_block.main_blkaddr) +
+			ckp->cur_node_segno[0] * config.blks_per_seg);
 
-	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting segment summary, ckp at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
-	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
-		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
-		return -1;
-	}
+	memcpy(sum_buf_ptr, &sum->n_nats, SUM_JOURNAL_SIZE);
+	sum_buf_ptr += SUM_JOURNAL_SIZE;
 
-	/* 4. Fill segment summary for data block to zero. */
 	memset(sum, 0, sizeof(struct f2fs_summary_block));
-	SET_SUM_TYPE((&sum->footer), SUM_TYPE_DATA);
-
 	/* inode sit for root */
 	sum->n_sits = cpu_to_le16(6);
 	sum->sit_j.entries[0].segno = ckp->cur_node_segno[0];
@@ -622,14 +645,25 @@ static int f2fs_write_check_point_pack(void)
 	sum->sit_j.entries[5].segno = ckp->cur_data_segno[2];
 	sum->sit_j.entries[5].se.vblocks = cpu_to_le16((CURSEG_COLD_DATA << 10));
 
+	memcpy(sum_buf_ptr, &sum->n_sits, SUM_JOURNAL_SIZE);
+	sum_buf_ptr += SUM_JOURNAL_SIZE;
+
+	/* hot data summary */
+	sum_entry = (struct f2fs_summary *)sum_buf_ptr;
+	sum_entry->nid = super_block.root_ino;
+	sum_entry->ofs_in_node = 0;
+	/* warm data summary, nothing to do */
+	/* cold data summary, nothing to do */
+
 	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting data sit for root, at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
-	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
+	DBG(1, "\tWriting Segment summary for HOT/WARM/COLD_DATA, at offset 0x%08"PRIx64"\n",
+			cp_seg_blk_offset);
+	if (dev_write(sum_buf, cp_seg_blk_offset, blk_size_bytes)) {
 		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
 		return -1;
 	}
 
-	/* 5. Prepare and write Segment summary for node blocks */
+	/* Prepare and write Segment summary for HOT_NODE */
 	memset(sum, 0, sizeof(struct f2fs_summary_block));
 	SET_SUM_TYPE((&sum->footer), SUM_TYPE_NODE);
 
@@ -637,34 +671,37 @@ static int f2fs_write_check_point_pack(void)
 	sum->entries[0].ofs_in_node = 0;
 
 	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting Segment summary for node blocks, at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
+	DBG(1, "\tWriting Segment summary for HOT_NODE, at offset 0x%08"PRIx64"\n",
+			cp_seg_blk_offset);
 	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
 		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
 		return -1;
 	}
 
-	/* 6. Fill segment summary for data block to zero. */
+	/* Fill segment summary for WARM_NODE to zero. */
 	memset(sum, 0, sizeof(struct f2fs_summary_block));
 	SET_SUM_TYPE((&sum->footer), SUM_TYPE_NODE);
 
 	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting Segment summary for data block (1/2), at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
+	DBG(1, "\tWriting Segment summary for WARM_NODE, at offset 0x%08"PRIx64"\n",
+			cp_seg_blk_offset);
 	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
 		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
 		return -1;
 	}
 
-	/* 7. Fill segment summary for data block to zero. */
+	/* Fill segment summary for COLD_NODE to zero. */
 	memset(sum, 0, sizeof(struct f2fs_summary_block));
 	SET_SUM_TYPE((&sum->footer), SUM_TYPE_NODE);
 	cp_seg_blk_offset += blk_size_bytes;
-	DBG(1, "\tWriting Segment summary for data block (2/2), at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
+	DBG(1, "\tWriting Segment summary for COLD_NODE, at offset 0x%08"PRIx64"\n",
+			cp_seg_blk_offset);
 	if (dev_write(sum, cp_seg_blk_offset, blk_size_bytes)) {
 		MSG(1, "\tError: While writing the sum_blk to disk!!!\n");
 		return -1;
 	}
 
-	/* 8. cp page2 */
+	/* cp page2 */
 	cp_seg_blk_offset += blk_size_bytes;
 	DBG(1, "\tWriting cp page2, at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
 	if (dev_write(ckp, cp_seg_blk_offset, blk_size_bytes)) {
@@ -672,7 +709,7 @@ static int f2fs_write_check_point_pack(void)
 		return -1;
 	}
 
-	/* 9. cp page 1 of check point pack 2
+	/* cp page 1 of check point pack 2
 	 * Initiatialize other checkpoint pack with version zero
 	 */
 	ckp->checkpoint_ver = 0;
@@ -698,7 +735,7 @@ static int f2fs_write_check_point_pack(void)
 		}
 	}
 
-	/* 10. cp page 2 of check point pack 2 */
+	/* cp page 2 of check point pack 2 */
 	cp_seg_blk_offset += blk_size_bytes * (le32_to_cpu(ckp->cp_pack_total_block_count)
 			- le32_to_cpu(super_block.cp_payload) - 1);
 	DBG(1, "\tWriting cp page 2 of checkpoint pack 2, at offset 0x%08"PRIx64"\n", cp_seg_blk_offset);
@@ -707,8 +744,9 @@ static int f2fs_write_check_point_pack(void)
 		return -1;
 	}
 
-	free(sum) ;
-	free(ckp) ;
+	free(sum_buf);
+	free(sum);
+	free(ckp);
 	free(cp_payload);
 	return	0;
 }
diff --git a/mkfs/f2fs_format_main.c b/mkfs/f2fs_format_main.c
index fa92845..02e2420 100644
--- a/mkfs/f2fs_format_main.c
+++ b/mkfs/f2fs_format_main.c
@@ -106,7 +106,8 @@ static void f2fs_parse_options(int argc, char *argv[])
 	if ((optind + 1) < argc) {
 		/* We have a sector count. */
 		config.total_sectors = atoll(argv[optind+1]);
-		MSG(0, "\ttotal_sectors=%lu (%s bytes)\n", config.total_sectors, argv[optind+1]);
+		MSG(0, "\ttotal_sectors=%08"PRIx64" (%s bytes)\n",
+				config.total_sectors, argv[optind+1]);
 	}
 
 	config.reserved_segments  =
diff --git a/mkfs/f2fs_format_utils.c b/mkfs/f2fs_format_utils.c
index 6792ce0..bce5731 100644
--- a/mkfs/f2fs_format_utils.c
+++ b/mkfs/f2fs_format_utils.c
@@ -6,12 +6,17 @@
  *
  * Dual licensed under the GPL or LGPL version 2 licenses.
  */
+#define _LARGEFILE_SOURCE
 #define _LARGEFILE64_SOURCE
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
 
 #include <stdio.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 
 #ifndef ANDROID
 #include "f2fs_fs.h"
@@ -22,6 +27,9 @@
 #ifdef HAVE_LINUX_FS_H
 #include <linux/fs.h>
 #endif
+#ifdef HAVE_LINUX_FALLOC_H
+#include <linux/falloc.h>
+#endif
 
 int f2fs_trim_device()
 {
@@ -41,9 +49,15 @@ int f2fs_trim_device()
 
 #if defined(WITH_BLKDISCARD) && defined(BLKDISCARD)
 	MSG(0, "Info: Discarding device\n");
-	if (S_ISREG(stat_buf.st_mode))
+	if (S_ISREG(stat_buf.st_mode)) {
+#ifdef FALLOC_FL_PUNCH_HOLE
+		if (fallocate(config.fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
+				range[0], range[1]) < 0) {
+			MSG(0, "Info: fallocate(PUNCH_HOLE|KEEP_SIZE) is failed\n");
+		}
+#endif
 		return 0;
-	else if (S_ISBLK(stat_buf.st_mode)) {
+	} else if (S_ISBLK(stat_buf.st_mode)) {
 		if (ioctl(config.fd, BLKDISCARD, &range) < 0) {
 			MSG(0, "Info: This device doesn't support TRIM\n");
 		} else {
diff --git a/scripts/tracepoint.sh b/scripts/tracepoint.sh
index 7f5a9b8..15588d7 100755
--- a/scripts/tracepoint.sh
+++ b/scripts/tracepoint.sh
@@ -5,6 +5,9 @@ dev=$(((8<<20) + 17)) # sdb1 (8,17)
 
 echo 1 > $TRACE/tracing_on
 
+# mmc tracepoints
+echo 0 > $TRACE/events/mmc/enable
+
 # block tracepoints
 #echo "dev == $dev" > $TRACE/events/block/block_rq_complete/filter
 echo 0 > $TRACE/events/block/block_rq_complete/enable
@@ -43,11 +46,14 @@ R=0
 W=0
 echo $R > $TRACE/events/f2fs/f2fs_readpage/enable
 echo $W > $TRACE/events/f2fs/f2fs_writepage/enable
-echo $W > $TRACE/events/f2fs/f2fs_submit_write_bio/enable
-echo $R > $TRACE/events/f2fs/f2fs_submit_read_bio/enable
+echo $W > $TRACE/events/f2fs/f2fs_write_begin/enable
+echo $W > $TRACE/events/f2fs/f2fs_write_end/enable
 
 echo 0 > $TRACE/events/f2fs/f2fs_submit_page_bio/enable
 echo 0 > $TRACE/events/f2fs/f2fs_submit_page_mbio/enable
+echo $R > $TRACE/events/f2fs/f2fs_submit_read_bio/enable
+echo $W > $TRACE/events/f2fs/f2fs_submit_write_bio/enable
+
 echo 0 > $TRACE/events/f2fs/f2fs_issue_discard/enable
 echo 0 > $TRACE/events/f2fs/f2fs_issue_flush/enable
 
diff --git a/tools/f2fstat.c b/tools/f2fstat.c
index 89dd7ff..7de734d 100644
--- a/tools/f2fstat.c
+++ b/tools/f2fstat.c
@@ -221,10 +221,66 @@ void parse_option(int argc, char *argv[], struct options *opt)
 	}
 }
 
-void print_head(void)
+void __make_head(char *head, int index, int i, int len)
 {
-	fprintf(stderr, "---utilization--- -----------main area-------- ---------balancing async------- ---gc--- ---alloc--- -----memory-----\n");
-	fprintf(stderr, "util  node   data   free  valid  dirty prefree node  dent meta  sit   nat fnid  cp   gc    ssr    lfs  total  node  meta\n");
+	char name_h[5][20] = {"main segments", "page/slab caches", "cp/gc", "blks", "memory"};
+	int half = (len - strlen(name_h[i])) / 2;
+
+	*(head + index) = '|';
+	index++;
+	memset(head + index, '-', half);
+	index += half;
+	strcpy(head + index, name_h[i]);
+	index += strlen(name_h[i]);
+	memset(head + index, '-', half);
+}
+
+void print_head(char *res)
+{
+	char *ptr, *ptr_buf;
+	char buf[1024], head[1024];
+	char name[20][10] = {"util", "node", "data", "free", "valid", "dirty", "prefree", "node", "dent", "meta",
+		"sit", "nat", "fnid", "cp", "gc", "ssr", "lfs", "total", "node", "meta"};
+	int i, len, prev_index = 0;
+
+	ptr_buf = buf;
+	memset(buf, ' ', 1024);
+	memset(head, ' ', 1024);
+
+	for (i = 0; i < 20; i++) {
+		ptr = (i == 0) ? strtok(res, " ") : strtok(NULL, " ");
+		strncpy(ptr_buf, name[i], strlen(name[i]));
+		if (i == 1) {
+			prev_index = ptr_buf - buf - 1;
+		} else if (i == 7) {
+			len = (ptr_buf - buf) - 1 - prev_index;
+			__make_head(head, prev_index, 0, len);
+			prev_index = ptr_buf - buf - 1;
+		} else if (i == 13) {
+			len = (ptr_buf - buf) - 1 - prev_index;
+			__make_head(head, prev_index, 1, len);
+			prev_index = ptr_buf - buf - 1;
+		} else if (i == 15) {
+			len = (ptr_buf - buf) - 1 - prev_index;
+			__make_head(head, prev_index, 2, len);
+			prev_index = ptr_buf - buf - 1;
+		} else if (i == 17) {
+			len = (ptr_buf - buf) - 1 - prev_index;
+			__make_head(head, prev_index, 3, len);
+			prev_index = ptr_buf - buf - 1;
+		}
+
+		len = strlen(ptr);
+		ptr_buf += (len > strlen(name[i]) ? len : strlen(name[i])) + 1;
+	}
+
+	len = (ptr_buf - buf) - 1 - prev_index;
+	__make_head(head, prev_index, 4, len);
+
+	*ptr_buf = 0;
+	*(head + (ptr_buf - buf - 1)) = '|';
+	*(head + (ptr_buf - buf)) = 0;
+	fprintf(stderr, "%s\n%s\n", head, buf);
 }
 
 #ifndef ANDROID
@@ -233,7 +289,8 @@ int main(int argc, char *argv[])
 int f2fstat_main(int argc, char *argv[])
 #endif
 {
-	char format[] = "%3ld %6ld %6ld %6ld %6ld %6ld %6ld %5ld %5ld %3ld %5ld %5ld %3ld %3ld %3ld %6ld %6ld %6ld %6ld %6ld\n";
+	char format[] = "%4ld %4ld %4ld %4ld %5ld %5ld %7ld %4ld %4ld %4ld %3ld %3ld %4ld %2ld %2ld %3ld %3ld %5ld %4ld %4ld";
+	char buf[1024], tmp[1024];
 	int head_interval;
 	struct options opt = {
 		.delay = 1,
@@ -247,20 +304,22 @@ int f2fstat_main(int argc, char *argv[])
 	parse_option(argc, argv, &opt);
 	head_interval = opt.interval;
 
-	print_head();
 	while (1) {
-		if (head_interval-- == 0) {
-			print_head();
-			head_interval = opt.interval;
-		}
-
+		memset(buf, 0, 1024);
 		f2fstat(&opt);
-
-		fprintf(stderr, format, util, used_node_blks, used_data_blks,
+		sprintf(buf, format, util, used_node_blks, used_data_blks,
 			free_segs, valid_segs, dirty_segs, prefree_segs,
 			dirty_node, dirty_dents, dirty_meta, dirty_sit, nat_caches, free_nids,
 			cp, gc, ssr_blks, lfs_blks, memory_kb, node_kb, meta_kb);
 
+		strcpy(tmp, buf);
+		if (head_interval == opt.interval)
+			print_head(tmp);
+		if (head_interval-- == 0)
+			head_interval = opt.interval;
+
+		fprintf(stderr, "%s\n", buf);
+
 		sleep(opt.delay);
 	}
 
-- 
2.7.4

